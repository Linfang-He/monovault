
@inproceedings{10.1109/SP.2015.9,
  title = {{{CHERI}}: {{A}} Hybrid Capability-System Architecture for Scalable Software Compartmentalization},
  booktitle = {Proceedings of the 2015 {{IEEE}} Symposium on Security and Privacy},
  author = {Watson, Robert N. M. and Woodruff, Jonathan and Neumann, Peter G. and Moore, Simon W. and Anderson, Jonathan and Chisnall, David and Dave, Nirav and Davis, Brooks and Gudka, Khilan and Laurie, Ben and Murdoch, Steven J. and Norton, Robert and Roe, Michael and Son, Stacey and Vadera, Munraj},
  date = {2015},
  series = {{{SP}} '15},
  pages = {20--37},
  publisher = {{IEEE Computer Society}},
  location = {{USA}},
  doi = {10.1109/SP.2015.9},
  url = {https://doi.org/10.1109/SP.2015.9},
  abstract = {CHERI extends a conventional RISC Instruction-Set Architecture, compiler, and operating system to support fine-grained, capability-based memory protection to mitigate memory-related vulnerabilities in C-language TCBs. We describe how CHERI capabilities can also underpin a hardware-software object-capability model for application compartmentalization that can mitigate broader classes of attack. Prototyped as an extension to the open-source 64-bit BERI RISC FPGA soft-core processor, Free BSD operating system, and LLVM compiler, we demonstrate multiple orders-of-magnitude improvement in scalability, simplified programmability, and resulting tangible security benefits as compared to compartmentalization based on pure Memory-Management Unit (MMU) designs. We evaluate incrementally deployable CHERI-based compartmentalization using several real-world UNIX libraries and applications.},
  isbn = {978-1-4673-6949-7},
  pagetotal = {18},
  keywords = {capability,cse227,security}
}

@article{10.1109/TNET.2002.808407,
  title = {Chord: {{A}} Scalable Peer-to-Peer Lookup Protocol for Internet Applications},
  author = {Stoica, Ion and Morris, Robert and Liben-Nowell, David and Karger, David R. and Kaashoek, M. Frans and Dabek, Frank and Balakrishnan, Hari},
  date = {2003-02},
  journaltitle = {IEEE/ACM Transactions on Networking},
  shortjournal = {IEEE/ACM Trans. Netw.},
  volume = {11},
  number = {1},
  pages = {17--32},
  publisher = {{IEEE Press}},
  issn = {1063-6692},
  doi = {10.1109/TNET.2002.808407},
  url = {https://doi.org/10.1109/TNET.2002.808407},
  abstract = {A fundamental problem that confronts peer-to-peer applications is the efficient location of the node that stores a desired data item. This paper presents Chord, a distributed lookup protocol that addresses this problem. Chord provides support for just one operation: given a key, it maps the key onto a node. Data location can be easily implemented on top of Chord by associating a key with each data item, and storing the key/data pair at the node to which the key maps. Chord adapts efficiently as nodes join and leave the system, and can answer queries even if the system is continuously changing. Results from theoretical analysis and simulations show that Chord is scalable: Communication cost and the state maintained by each node scale logarithmically with the number of Chord nodes.},
  issue_date = {February 2003},
  pagetotal = {16},
  keywords = {cse223,distributed,system}
}

@article{10.1145/146941.146942,
  title = {Disconnected Operation in the Coda File System},
  author = {Kistler, James J. and Satyanarayanan, M.},
  date = {1992-02},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {10},
  number = {1},
  pages = {3--25},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  issn = {0734-2071},
  doi = {10.1145/146941.146942},
  url = {https://doi.org/10.1145/146941.146942},
  abstract = {Disconnected operation is a mode of operation that enables a client to continue accessing critical data during temporary failures of a shared data repository. An important, though not exclusive, application of disconnected operation is in supporting portable computers. In this paper, we show that disconnected operation is feasible, efficient and usable by describing its design and implementation in the Coda File System. The central idea behind our work is that caching of data, now widely used for performance, can also be exploited to improve availability.},
  issue_date = {Feb. 1992},
  pagetotal = {23},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/X5F4CCKD/Kistler and Satyanarayanan - 1992 - Disconnected operation in the coda file system.pdf}
}

@inproceedings{10.1145/1629575.1629577,
  title = {{{FAWN}}: {{A}} Fast Array of Wimpy Nodes},
  booktitle = {Proceedings of the {{ACM SIGOPS}} 22nd Symposium on Operating Systems Principles},
  author = {Andersen, David G. and Franklin, Jason and Kaminsky, Michael and Phanishayee, Amar and Tan, Lawrence and Vasudevan, Vijay},
  date = {2009},
  series = {{{SOSP}} '09},
  pages = {1--14},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/1629575.1629577},
  url = {https://doi.org/10.1145/1629575.1629577},
  abstract = {This paper presents a new cluster architecture for low-power data-intensive computing. FAWN couples low-power embedded CPUs to small amounts of local flash storage, and balances computation and I/O capabilities to enable efficient, massively parallel access to data.The key contributions of this paper are the principles of the FAWN architecture and the design and implementation of FAWN-KV–a consistent, replicated, highly available, and high-performance key-value storage system built on a FAWN prototype. Our design centers around purely log-structured datastores that provide the basis for high performance on flash storage, as well as for replication and consistency obtained using chain replication on a consistent hashing ring. Our evaluation demonstrates that FAWN clusters can handle roughly 350 key-value queries per Joule of energy–two orders of magnitude more than a disk-based system.},
  isbn = {978-1-60558-752-3},
  pagetotal = {14},
  keywords = {cse223,system},
  file = {/Users/yuan/Zotero/storage/QKBGXMDG/Andersen et al. - 2009 - FAWN A fast array of wimpy nodes.pdf}
}

@article{10.1145/224057.224070,
  title = {Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System},
  author = {Terry, D. B. and Theimer, M. M. and Petersen, Karin and Demers, A. J. and Spreitzer, M. J. and Hauser, C. H.},
  date = {1995-12},
  journaltitle = {SIGOPS Oper. Syst. Rev.},
  volume = {29},
  number = {5},
  pages = {172--182},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  issn = {0163-5980},
  doi = {10.1145/224057.224070},
  url = {https://doi.org/10.1145/224057.224070},
  issue_date = {Dec. 3, 1995},
  pagetotal = {11},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/QT7YN75D/Terry et al. - 1995 - Managing update conflicts in bayou, a weakly conne.pdf}
}

@inproceedings{10.1145/268998.266694,
  title = {Frangipani: {{A}} Scalable Distributed File System},
  booktitle = {Proceedings of the Sixteenth {{ACM}} Symposium on Operating Systems Principles},
  author = {Thekkath, Chandramohan A. and Mann, Timothy and Lee, Edward K.},
  date = {1997},
  series = {{{SOSP}} '97},
  pages = {224--237},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/268998.266694},
  url = {https://doi.org/10.1145/268998.266694},
  isbn = {0-89791-916-5},
  pagetotal = {14},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/QF7SAIRU/Thekkath et al. - 1997 - Frangipani A scalable distributed file system.pdf}
}

@inproceedings{10.1145/2872362.2872364,
  title = {How to Build Static Checking Systems Using Orders of Magnitude Less Code},
  booktitle = {Proceedings of the Twenty-First International Conference on Architectural Support for Programming Languages and Operating Systems},
  author = {Brown, Fraser and Nötzli, Andres and Engler, Dawson},
  date = {2016},
  series = {{{ASPLOS}} '16},
  pages = {143--157},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/2872362.2872364},
  url = {https://doi.org/10.1145/2872362.2872364},
  abstract = {Modern static bug finding tools are complex. They typically consist of hundreds of thousands of lines of code, and most of them are wedded to one language (or even one compiler). This complexity makes the systems hard to understand, hard to debug, and hard to retarget to new languages, thereby dramatically limiting their scope. This paper reduces checking system complexity by addressing a fundamental assumption, the assumption that checkers must depend on a full-blown language specification and compiler front end. Instead, our program checkers are based on drastically incomplete language grammars ("micro-grammars") that describe only portions of a language relevant to a checker. As a result, our implementation is tiny-roughly 2500 lines of code, about two orders of magnitude smaller than a typical system. We hope that this dramatic increase in simplicity will allow people to use more checkers on more systems in more languages.We implement our approach in μchex, a language-agnostic framework for writing static bug checkers. We use it to build micro-grammar based checkers for six languages (C, the C preprocessor, C++, Java, JavaScript, and Dart) and find over 700 errors in real-world projects.},
  isbn = {978-1-4503-4091-5},
  pagetotal = {15},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/3M47Y3UF/Brown et al. - 2016 - How to build static checking systems using orders .pdf}
}

@inproceedings{10.1145/3132747.3132748,
  title = {Hyperkernel: {{Push-button}} Verification of an {{OS}} Kernel},
  booktitle = {Proceedings of the 26th Symposium on Operating Systems Principles},
  author = {Nelson, Luke and Sigurbjarnarson, Helgi and Zhang, Kaiyuan and Johnson, Dylan and Bornholt, James and Torlak, Emina and Wang, Xi},
  date = {2017},
  series = {{{SOSP}} '17},
  pages = {252--269},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/3132747.3132748},
  url = {https://doi.org/10.1145/3132747.3132748},
  abstract = {This paper describes an approach to designing, implementing, and formally verifying the functional correctness of an OS kernel, named Hyperkernel, with a high degree of proof automation and low proof burden. We base the design of Hyperkernel's interface on xv6, a Unix-like teaching operating system. Hyperkernel introduces three key ideas to achieve proof automation: it finitizes the kernel interface to avoid unbounded loops or recursion; it separates kernel and user address spaces to simplify reasoning about virtual memory; and it performs verification at the LLVM intermediate representation level to avoid modeling complicated C semantics.We have verified the implementation of Hyperkernel with the Z3 SMT solver, checking a total of 50 system calls and other trap handlers. Experience shows that Hyperkernel can avoid bugs similar to those found in xv6, and that the verification of Hyperkernel can be achieved with a low proof burden.},
  isbn = {978-1-4503-5085-3},
  pagetotal = {18},
  keywords = {cse227,security,verification},
  file = {/Users/yuan/Zotero/storage/6NJ9FTGT/Nelson et al. - 2017 - Hyperkernel Push-button verification of an OS ker.pdf}
}

@inproceedings{10.1145/3243734.3243745,
  title = {When Good Components Go Bad: {{Formally}} Secure Compilation despite Dynamic Compromise},
  booktitle = {Proceedings of the 2018 {{ACM SIGSAC}} Conference on Computer and Communications Security},
  author = {Abate, Carmine and Azevedo de Amorim, Arthur and Blanco, Roberto and Evans, Ana Nora and Fachini, Guglielmo and Hritcu, Catalin and Laurent, Théo and Pierce, Benjamin C. and Stronati, Marco and Tolmach, Andrew},
  date = {2018},
  series = {{{CCS}} '18},
  pages = {1351--1368},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/3243734.3243745},
  url = {https://doi.org/10.1145/3243734.3243745},
  abstract = {We propose a new formal criterion for evaluating secure compilation schemes for unsafe languages, expressing end-to-end security guarantees for software components that may become compromised after encountering undefined behavior—for example, by accessing an array out of bounds. Our criterion is the first to model dynamic compromise in a system of mutually distrustful components with clearly specified privileges. It articulates how each component should be protected from all the others—in particular, from components that have encountered undefined behavior and become compromised. Each component receives secure compilation guarantees—in particular, its internal invariants are protected from compromised components—up to the point when this component itself becomes compromised, after which we assume an attacker can take complete control and use this component's privileges to attack other components. More precisely, a secure compilation chain must ensure that a dynamically compromised component cannot break the safety properties of the system at the target level any more than an arbitrary attacker-controlled component (with the same interface and privileges, but without undefined behaviors) already could at the source level. To illustrate the model, we construct a secure compilation chain for a small unsafe language with buffers, procedures, and components, targeting a simple abstract machine with built-in compartmentalization. We give a careful proof (mostly machine-checked in Coq) that this compiler satisfies our secure compilation criterion. Finally, we show that the protection guarantees offered by the compartmentalized abstract machine can be achieved at the machine-code level using either software fault isolation or a tag-based reference monitor.},
  isbn = {978-1-4503-5693-0},
  pagetotal = {18},
  keywords = {227 project,cse227,undefined behavior}
}

@inproceedings{10.1145/3314221.3314590,
  title = {Simple and Precise Static Analysis of Untrusted Linux Kernel Extensions},
  booktitle = {Proceedings of the 40th {{ACM SIGPLAN}} Conference on Programming Language Design and Implementation},
  author = {Gershuni, Elazar and Amit, Nadav and Gurfinkel, Arie and Narodytska, Nina and Navas, Jorge A. and Rinetzky, Noam and Ryzhyk, Leonid and Sagiv, Mooly},
  date = {2019},
  series = {{{PLDI}} 2019},
  pages = {1069--1084},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/3314221.3314590},
  url = {https://doi.org/10.1145/3314221.3314590},
  abstract = {Extended Berkeley Packet Filter (eBPF) is a Linux subsystem that allows safely executing untrusted user-defined extensions inside the kernel. It relies on static analysis to protect the kernel against buggy and malicious extensions. As the eBPF ecosystem evolves to support more complex and diverse extensions, the limitations of its current verifier, including high rate of false positives, poor scalability, and lack of support for loops, have become a major barrier for developers. We design a static analyzer for eBPF within the framework of abstract interpretation. Our choice of abstraction is based on common patterns found in many eBPF programs. We observed that eBPF programs manipulate memory in a rather disciplined way which permits analyzing them successfully with a scalable mixture of very-precise abstraction of certain bounded regions with coarser abstractions of other parts of the memory. We use the Zone domain, a simple domain that tracks differences between pairs of registers and offsets, to achieve precise and scalable analysis. We demonstrate that this abstraction is as precise in practice as more costly abstract domains like Octagon and Polyhedra. Furthermore, our evaluation, based on hundreds of real-world eBPF programs, shows that the new tool generates no more false alarms than the existing Linux verifier, while it supports a wider class of programs (including programs with loops) and has better asymptotic complexity.},
  isbn = {978-1-4503-6712-7},
  pagetotal = {16},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/TH4TS5WV/Gershuni et al. - 2019 - Simple and precise static analysis of untrusted li.pdf}
}

@inproceedings{10.1145/3385412.3385968,
  title = {Towards a Verified Range Analysis for {{JavaScript JITs}}},
  booktitle = {Proceedings of the 41st {{ACM SIGPLAN}} Conference on Programming Language Design and Implementation},
  author = {Brown, Fraser and Renner, John and Nötzli, Andres and Lerner, Sorin and Shacham, Hovav and Stefan, Deian},
  date = {2020},
  series = {{{PLDI}} 2020},
  pages = {135--150},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/3385412.3385968},
  url = {https://doi.org/10.1145/3385412.3385968},
  abstract = {We present VeRA, a system for verifying the range analysis pass in browser just-in-time (JIT) compilers. Browser developers write range analysis routines in a subset of C++, and verification developers write infrastructure to verify custom analysis properties. Then, VeRA automatically verifies the range analysis routines, which browser developers can integrate directly into the JIT. We use VeRA to translate and verify Firefox range analysis routines, and it detects a new, confirmed bug that has existed in the browser for six years.},
  isbn = {978-1-4503-7613-6},
  pagetotal = {16},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/8CEFWSCM/Brown et al. - 2020 - Towards a verified range analysis for JavaScript J.pdf}
}

@article{10.1145/3399742,
  title = {Spectre Attacks: {{Exploiting}} Speculative Execution},
  author = {Kocher, Paul and Horn, Jann and Fogh, Anders and Genkin, Daniel and Gruss, Daniel and Haas, Werner and Hamburg, Mike and Lipp, Moritz and Mangard, Stefan and Prescher, Thomas and Schwarz, Michael and Yarom, Yuval},
  date = {2020-06},
  journaltitle = {Communications of The Acm},
  shortjournal = {Commun. ACM},
  volume = {63},
  number = {7},
  pages = {93--101},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  issn = {0001-0782},
  doi = {10.1145/3399742},
  url = {https://doi.org/10.1145/3399742},
  abstract = {Modern processors use branch prediction and speculative execution to maximize performance. For example, if the destination of a branch depends on a memory value that is in the process of being read, CPUs will try to guess the destination and attempt to execute ahead. When the memory value finally arrives, the CPU either discards or commits the speculative computation. Speculative logic is unfaithful in how it executes, can access the victim's memory and registers, and can perform operations with measurable side effects.Spectre attacks involve inducing a victim to speculatively perform operations that would not occur during correct program execution and which leak the victim's confidential information via a side channel to the adversary. This paper describes practical attacks that combine methodology from side-channel attacks, fault attacks, and return-oriented programming that can read arbitrary memory from the victim's process. More broadly, the paper shows that speculative execution implementations violate the security assumptions underpinning numerous software security mechanisms, such as operating system process separation, containerization, just-in-time (JIT) compilation, and countermeasures to cache timing and side-channel attacks. These attacks represent a serious threat to actual systems because vulnerable speculative execution capabilities are found in microprocessors from Intel, AMD, and ARM that are used in billions of devices.Although makeshift processor-specific countermeasures are possible in some cases, sound solutions will require fixes to processor designs as well as updates to instruction set architectures (ISAs) to give hardware architects and software developers a common understanding as to what computation state CPU implementations are (and are not) permitted to leak.},
  issue_date = {July 2020},
  pagetotal = {9},
  keywords = {cse227,security}
}

@inproceedings{10.1145/3460120.3484736,
  title = {Supply-Chain Vulnerability Elimination via Active Learning and Regeneration},
  booktitle = {Proceedings of the 2021 {{ACM SIGSAC}} Conference on Computer and Communications Security},
  author = {Vasilakis, Nikos and Benetopoulos, Achilles and Handa, Shivam and Schoen, Alizee and Shen, Jiasi and Rinard, Martin C.},
  date = {2021},
  series = {{{CCS}} '21},
  pages = {1755--1770},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/3460120.3484736},
  url = {https://doi.org/10.1145/3460120.3484736},
  abstract = {Software supply-chain attacks target components that are integrated into client applications. Such attacks often target widely-used components, with the attack taking place via operations (for example, file system or network accesses) that do not affect those aspects of component behavior that the client observes. We propose new active library learning and regeneration (ALR) techniques for inferring and regenerating the client-observable behavior of software components. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the component, and observes the resulting outputs to infer a model of the component's behavior as a program in a domain-specific language. We present Harp, an ALR system for string processing components. We apply Harp to successfully infer and regenerate string-processing components written in JavaScript and C/C++. Our results indicate that, in the majority of cases, Harp completes the regeneration in less than a minute, remains fully compatible with the original library, and delivers performance indistinguishable from the original library. We also demonstrate that Harp can eliminate vulnerabilities associated with libraries targeted in several highly visible security incidents, specifically event-stream, left-pad, and string-compare.},
  isbn = {978-1-4503-8454-4},
  pagetotal = {16},
  keywords = {cse227,security}
}

@article{10.1145/3498688,
  title = {Isolation without Taxation: {{Near-zero-cost}} Transitions for {{WebAssembly}} and {{SFI}}},
  author = {Kolosick, Matthew and Narayan, Shravan and Johnson, Evan and Watt, Conrad and LeMay, Michael and Garg, Deepak and Jhala, Ranjit and Stefan, Deian},
  date = {2022-01},
  journaltitle = {Proc. ACM Program. Lang.},
  volume = {6},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/3498688},
  url = {https://doi.org/10.1145/3498688},
  abstract = {Software sandboxing or software-based fault isolation (SFI) is a lightweight approach to building secure systems out of untrusted components. Mozilla, for example, uses SFI to harden the Firefox browser by sandboxing third-party libraries, and companies like Fastly and Cloudflare use SFI to safely co-locate untrusted tenants on their edge clouds. While there have been significant efforts to optimize and verify SFI enforcement, context switching in SFI systems remains largely unexplored: almost all SFI systems use heavyweight transitions that are not only error-prone but incur significant performance overhead from saving, clearing, and restoring registers when context switching. We identify a set of zero-cost conditions that characterize when sandboxed code has sufficient structured to guarantee security via lightweight zero-cost transitions (simple function calls). We modify the Lucet Wasm compiler and its runtime to use zero-cost transitions, eliminating the undue performance tax on systems that rely on Lucet for sandboxing (e.g., we speed up image and font rendering in Firefox by up to 29.7\% and 10\% respectively). To remove the Lucet compiler and its correct implementation of the Wasm specification from the trusted computing base, we (1) develop a static binary verifier, VeriZero, which (in seconds) checks that binaries produced by Lucet satisfy our zero-cost conditions, and (2) prove the soundness of VeriZero by developing a logical relation that captures when a compiled Wasm function is semantically well-behaved with respect to our zero-cost conditions. Finally, we show that our model is useful beyond Wasm by describing a new, purpose-built SFI system, SegmentZero32, that uses x86 segmentation and LLVM with mostly off-the-shelf passes to enforce our zero-cost conditions; our prototype performs on-par with the state-of-the-art Native Client SFI system.},
  articleno = {27},
  issue = {POPL},
  issue_date = {January 2022},
  pagetotal = {30},
  keywords = {227 project,cse227,sandboxing,security,software fault isolation}
}

@article{10.1145/7351.7478,
  title = {Reliable Communication in the Presence of Failures},
  author = {Birman, Kenneth P. and Joseph, Thomas A.},
  date = {1987-01},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {5},
  number = {1},
  pages = {47--76},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  issn = {0734-2071},
  doi = {10.1145/7351.7478},
  url = {https://doi.org/10.1145/7351.7478},
  abstract = {The design and correctness of a communication facility for a distributed computer system are reported on. The facility provides support for fault-tolerant process groups in the form of a family of reliable multicast protocols that can be used in both local- and wide-area networks. These protocols attain high levels of concurrency, while respecting application-specific delivery ordering constraints, and have varying cost and performance that depend on the degree of ordering desired. In particular, a protocol that enforces causal delivery orderings is introduced and shown to be a valuable alternative to conventional asynchronous communication protocols. The facility also ensures that the processes belonging to a fault-tolerant process group will observe consistent orderings of events affecting the group as a whole, including process failures, recoveries, migration, and dynamic changes to group properties like member rankings. A review of several uses for the protocols in the ISIS system, which supports fault-tolerant resilient objects and bulletin boards, illustrates the significant simplification of higher level algorithms made possible by our approach.},
  issue_date = {Feb. 1987},
  pagetotal = {30},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/SHE6X4H5/Birman and Joseph - 1987 - Reliable communication in the presence of failures.pdf}
}

@article{10.5555/1134782.1134786,
  title = {{{SSHFS}}: {{Super}} Easy File Access over {{SSH}}},
  author = {Hoskins, Matthew E.},
  date = {2006-06},
  journaltitle = {Linux J.},
  volume = {2006},
  number = {146},
  pages = {4},
  publisher = {{Belltown Media}},
  location = {{Houston, TX}},
  issn = {1075-3583},
  abstract = {SSH does more than just provide safe communications.},
  issue_date = {June 2006},
  keywords = {cse223,distributed,system}
}

@inproceedings{10.5555/1251353.1251369,
  title = {Preventing Privilege Escalation},
  booktitle = {Proceedings of the 12th Conference on {{USENIX}} Security Symposium - Volume 12},
  author = {Provos, Niels and Friedl, Markus and Honeyman, Peter},
  date = {2003},
  series = {{{SSYM}}'03},
  pages = {16},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {We introduce a system that eliminates the need to run programs in privileged process contexts. Using our system, programs run unprivileged but may execute certain operations with elevated privileges as determined by a configurable policy eliminating the need for suid or sgid binaries. We present the design and analysis of the "Systrace" facility which supports fine grained process confinement, intrusion detection, auditing and privilege elevation. It also facilitates the often difficult process of policy generation. With Systrace, it is possible to generate policies automatically in a training session or generate them interactively during program execution. The policies describe the desired behavior of services or user applications on a system call level and are enforced to prevent operations that are not explicitly permitted. We show that Systrace is efficient and does not impose significant performance penalties.},
  pagetotal = {1},
  keywords = {cse227,privilege,security},
  file = {/Users/yuan/Zotero/storage/EJ5I5Y22/Provos et al. - 2003 - Preventing privilege escalation.pdf}
}

@inproceedings{10.5555/1251375.1251380,
  title = {Privtrans: {{Automatically}} Partitioning Programs for Privilege Separation},
  booktitle = {Proceedings of the 13th Conference on {{USENIX}} Security Symposium - Volume 13},
  author = {Brumley, David and Song, Dawn},
  date = {2004},
  series = {{{SSYM}}'04},
  pages = {5},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {Privilege separation partitions a single program into two parts: a privileged program called the monitor and an unprivileged program called the slave. All trust and privileges are relegated to the monitor, which results in a smaller and more easily secured trust base. Previously the privilege separation procedure, i.e., partitioning one program into the monitor and slave, was done by hand [18, 28]. We design techniques and develop a tool called Privtrans that allows us to automatically integrate privilege separation into source code, provided a few programmer annotations. For instance, our approach can automatically integrate the privilege separation previously done by hand in OpenSSH, while enjoying similar security benefits. Additionally, we propose optimization techniques that augment static analysis with dynamic information. Our optimization techniques reduce the number of expensive calls made by the slave to the monitor. We show Privtrans is effective by integrating privilege separation into several open-source applications.},
  pagetotal = {1},
  keywords = {cse227,previlege,security},
  file = {/Users/yuan/Zotero/storage/T3RY79DT/Brumley and Song - 2004 - Privtrans Automatically partitioning programs for.pdf}
}

@inproceedings{10.5555/1267074.1267084,
  title = {{{TreadMarks}}: {{Distributed}} Shared Memory on Standard Workstations and Operating Systems},
  booktitle = {Proceedings of the {{USENIX}} Winter 1994 Technical Conference on {{USENIX}} Winter 1994 Technical Conference},
  author = {Keleher, Pete and Cox, Alan L. and Dwarkadas, Sandhya and Zwaenepoel, Willy},
  date = {1994},
  series = {{{WTEC}}'94},
  pages = {10},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {TreadMarks is a distributed shared memory (DSM) system for standard Unix systems such as SunOS and Ultrix. This paper presents a performance evaluation of TreadMarks running on Ultrix using DECstation-5000/240's that are connected by a 100-Mbps switch-based ATM LAN and a 10-Mbps Ethernet. Our objective is to determine the efficiency of a user-level DSM implementation on commercially available workstations and operating systems.We achieved good speedups on the 8-processor ATM network for Jacobi (7.4), TSP (7.2), Quicksort (6.3), and ILINK (5.7). For a slightly modified version of Water from the SPLASH benchmark suite, we achieved only moderate speedups (4.0) due to the high communication and synchronization rate. Speedups decline on the 10-Mbps Ethernet (5.5 for Jacobi, 6.5 for TSP, 4.2 for Quicksort, 5.1 for ILINK, and 2.1 for Water), reflecting the bandwidth limitations of the Ethernet. These results support the contention that, with suitable networking technology, DSM is a viable technique for parallel computation on clusters of workstations.To achieve these speedups, TreadMarks goes to great lengths to reduce the amount of communication performed to maintain memory consistency. It uses a lazy implementation of release consistency, and it allows multiple concurrent writers to modify a page, reducing the impact of false sharing. Great care was taken to minimize communication overhead. In particular, on the ATM network, we used a standard low-level protocol, AAL3/4, bypassing the TCP/IP protocol stack. Unix communication overhead, however, remains the main obstacle in the way of better performance for programs like Water. Compared to the Unix communication overhead, memory management cost (both kernel and user level) is small and wire time is negligible.This research was supported in part by the National Science Foundation under Grants CCR-9116343, CCR-9211004, CDA-9222911, and CDA-9310073, by the Texas Advanced Technology Program under Grant 003604014, and by a NASA Graduate Fellowship.},
  pagetotal = {1},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/DKAIIUYP/Keleher et al. - 1994 - TreadMarks Distributed shared memory on standard .pdf}
}

@inproceedings{10.5555/1267336.1267351,
  title = {Evaluating {{SFI}} for a {{CISC}} Architecture},
  booktitle = {Proceedings of the 15th Conference on {{USENIX}} Security Symposium - Volume 15},
  author = {McCamant, Stephen and Morrisett, Greg},
  date = {2006},
  series = {{{USENIX-SS}}'06},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {Executing untrusted code while preserving security requires that the code be prevented from modifying memory or executing instructions except as explicitly allowed. Software-based fault isolation (SFI) or "sandboxing" enforces such a policy by rewriting the untrusted code at the instruction level. However, the original sandboxing technique of Wahbe et al. is applicable only to RISC architectures, and most other previous work is either insecure, or has been not described in enough detail to give confidence in its security properties. We present a new sandboxing technique that can be applied to a CISC architecture like the IA-32, and whose application can be checked at load-time to minimize the TCB. We describe an implementation which provides a robust security guarantee and has low runtime overheads (an average of 21\% on the SPECint2000 benchmarks). We evaluate the utility of the technique by applying it to untrusted decompression modules in an archive tool, and its safety by constructing a machine-checked proof that any program approved by the verification algorithm will respect the desired safety property.},
  articleno = {15},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/QUR8XWC7/McCamant and Morrisett - 2006 - Evaluating SFI for a CISC architecture.pdf}
}

@inproceedings{10.5555/2387880.2387886,
  title = {Hails: {{Protecting}} Data Privacy in Untrusted Web Applications},
  booktitle = {Proceedings of the 10th {{USENIX}} Conference on Operating Systems Design and Implementation},
  author = {Giffin, Daniel B. and Levy, Amit and Stefan, Deian and Terei, David and Mazières, David and Mitchell, John C. and Russo, Alejandro},
  date = {2012},
  series = {{{OSDI}}'12},
  pages = {47--60},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {Modern extensible web platforms like Facebook and Yammer depend on third-party software to offer a rich experience to their users. Unfortunately, users running a third-party "app" have little control over what it does with their private data. Today's platforms offer only ad-hoc constraints on app behavior, leaving users an unfortunate trade-off between convenience and privacy. A principled approach to code confinement could allow the integration of untrusted codewhile enforcing flexible, end-to-end policies on data access. This paper presents a new web framework, Hails, that adds mandatory access control and a declarative policy language to the familiar MVC architecture. We demonstrate the flexibility of Hails through GitStar.com, a code-hosting website that enforces robust privacy policies on user data even while allowing untrusted apps to deliver extended features to users.},
  isbn = {978-1-931971-96-6},
  pagetotal = {14},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/RUNV8R25/Giffin et al. - 2012 - Hails Protecting data privacy in untrusted web ap.pdf}
}

@inproceedings{10.5555/2616448.2616486,
  title = {{{FaRM}}: {{Fast}} Remote Memory},
  booktitle = {Proceedings of the 11th {{USENIX}} Conference on Networked Systems Design and Implementation},
  author = {Dragojević, Aleksandar and Narayanan, Dushyanth and Hodson, Orion and Castro, Miguel},
  date = {2014},
  series = {{{NSDI}}'14},
  pages = {401--414},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {We describe the design and implementation of FaRM, a new main memory distributed computing platform that exploits RDMA to improve both latency and throughput by an order of magnitude relative to state of the art main memory systems that use TCP/IP. FaRM exposes the memory of machines in the cluster as a shared address space. Applications can use transactions to allocate, read, write, and free objects in the address space with location transparency. We expect this simple programming model to be sufficient for most application code. FaRM provides two mechanisms to improve performance where required: lock-free reads over RDMA, and support for collocating objects and function shipping to enable the use of efficient single machine transactions. FaRM uses RDMA both to directly access data in the shared address space and for fast messaging and is carefully tuned for the best RDMA performance. We used FaRM to build a key-value store and a graph store similar to Facebook's. They both perform well, for example, a 20-machine cluster can perform 167 million key-value lookups per second with a latency of 31µs.},
  isbn = {978-1-931971-09-6},
  pagetotal = {14},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/7EUDILC6/Dragojević et al. - 2014 - FaRM Fast remote memory.pdf}
}

@inproceedings{10.5555/296806.296824,
  title = {Practical Byzantine Fault Tolerance},
  booktitle = {Proceedings of the Third Symposium on Operating Systems Design and Implementation},
  author = {Castro, Miguel and Liskov, Barbara},
  date = {1999},
  series = {{{OSDI}} '99},
  pages = {173--186},
  publisher = {{USENIX Association}},
  location = {{USA}},
  isbn = {1-880446-39-1},
  pagetotal = {14},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/7EHBMMHL/Castro and Liskov - 1999 - Practical byzantine fault tolerance.pdf}
}

@incollection{10.5555/3488766.3488769,
  title = {Specification and Verification in the Field: {{Applying}} Formal Methods to {{BPF}} Just-in-Time Compilers in the Linux Kernel},
  booktitle = {Proceedings of the 14th {{USENIX}} Conference on Operating Systems Design and Implementation},
  author = {Nelson, Luke and Van Geffen, Jacob and Torlak, Emina and Wang, Xi},
  date = {2020},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {This paper describes our experience applying formal methods to a critical component in the Linux kernel, the just-in-time compilers ("JITs") for the Berkeley Packet Filter (BPF) virtual machine. We verify these JITs using Jitterbug, the first framework to provide a precise specification of JIT correctness that is capable of ruling out real-world bugs, and an automated proof strategy that scales to practical implementations. Using Jitterbug, we have designed, implemented, and verified a new BPF JIT for 32-bit RISC-V, found and fixed 16 previously unknown bugs in five other deployed JITs, and developed new JIT optimizations; all of these changes have been upstreamed to the Linux kernel. The results show that it is possible to build a verified component within a large, unverified system with careful design of specification and proof strategy.},
  articleno = {3},
  isbn = {978-1-939133-19-9},
  pagetotal = {21},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/IZS3EBSW/Nelson et al. - 2020 - Specification and verification in the field Apply.pdf}
}

@incollection{10.5555/3489212.3489224,
  title = {Sys: {{A Static}}/{{Symbolic}} Tool for Finding Good Bugs in Good (Browser) Code},
  booktitle = {Proceedings of the 29th {{USENIX}} Conference on Security Symposium},
  author = {Brown, Fraser and Stefan, Deian and Engler, Dawson},
  date = {2020},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {We describe and evaluate an extensible bug-finding tool, Sys, designed to automatically find security bugs in huge codebases, even when easy-to-find bugs have been already picked clean by years of aggressive automatic checking. Sys uses a two-step approach to find such tricky errors. First, it breaks down large–tens of millions of lines–systems into small pieces using user-extensible static checkers to quickly find and mark potential errorsites. Second, it uses user-extensible symbolic execution to deeply examine these potential errorsites for actual bugs. Both the checkers and the system itself are small (6KLOC total). Sys is flexible, because users must be able to exploit domain- or system-specific knowledge in order to detect errors and suppress false positives in real codebases. Sys finds many security bugs (51 bugs, 43 confirmed) in wellchecked code–the Chrome and Firefox web browsers–and code that some symbolic tools struggle with–the FreeBSD operating system. Sys's most interesting results include: an exploitable, cash bountied CVE in Chrome that was fixed in seven hours (and whose patch was backported in two days); a trio of bountied bugs with a CVE in Firefox; and a bountied bug in Chrome's audio support.},
  articleno = {12},
  isbn = {978-1-939133-17-5},
  pagetotal = {18},
  file = {/Users/yuan/Zotero/storage/CS8B26X7/Brown et al. - 2020 - Sys A StaticSymbolic tool for finding good bugs .pdf}
}

@incollection{10.5555/3489212.3489252,
  title = {Retrofitting Fine Grain Isolation in the Firefox Renderer},
  booktitle = {Proceedings of the 29th {{USENIX}} Conference on Security Symposium},
  author = {Narayan, Shravan and Disselkoen, Craig and Garfinkel, Tal and Froyd, Nathan and Rahm, Eric and Lerner, Sorin and Shacham, Hovav and Stefan, Deian},
  date = {2020},
  publisher = {{USENIX Association}},
  location = {{USA}},
  abstract = {Firefox and other major browsers rely on dozens of third-party libraries to render audio, video, images, and other content. These libraries are a frequent source of vulnerabilities. To mitigate this threat, we are migrating Firefox to an architecture that isolates these libraries in lightweight sandboxes, dramatically reducing the impact of a compromise.Retrofitting isolation can be labor-intensive, very prone to security bugs, and requires critical attention to performance. To help, we developed RLBox, a framework that minimizes the burden of converting Firefox to securely and efficiently use untrusted code. To enable this, RLBox employs static information flow enforcement, and lightweight dynamic checks, expressed directly in the C++ type system.RLBox supports efficient sandboxing through either software-based-fault isolation or multi-core process isolation. Performance overheads are modest and transient, and have only minor impact on page latency. We demonstrate this by sandboxing performance-sensitive image decoding libraries (libjpeg and libpng), video decoding libraries (libtheora and libvpx), the libvorbis audio decoding library, and the zlib decompression library.RLBox, using a WebAssembly sandbox, has been integrated into production Firefox to sandbox the libGraphite font shaping library.},
  articleno = {40},
  isbn = {978-1-939133-17-5},
  pagetotal = {18},
  keywords = {cse227,sandboxing,security}
}

@report{1885-40765,
  title = {The Rsync Algorithm},
  author = {Tridgell, Andrew and Mackerras, Paul},
  date = {1996},
  keywords = {cse223,distributed,system}
}

@inproceedings{7958598,
  title = {Finding and Preventing Bugs in {{JavaScript}} Bindings},
  booktitle = {2017 {{IEEE}} Symposium on Security and Privacy ({{SP}})},
  author = {Brown, Fraser and Narayan, Shravan and Wahby, Riad S. and Engler, Dawson and Jhala, Ranjit and Stefan, Deian},
  date = {2017},
  pages = {559--578},
  doi = {10.1109/SP.2017.68},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/ZBVPHNPM/Brown et al. - 2017 - Finding and preventing bugs in JavaScript bindings.pdf}
}

@article{abadiTensorFlowSystemLargescale,
  title = {{{TensorFlow}}: {{A}} System for Large-Scale Machine Learning},
  author = {Abadi, Martın and Barham, Paul and Chen, Jianmin and Chen, Zhifeng and Davis, Andy and Dean, Jeffrey and Devin, Matthieu and Ghemawat, Sanjay and Irving, Geoffrey and Isard, Michael and Kudlur, Manjunath and Levenberg, Josh and Monga, Rajat and Moore, Sherry and Murray, Derek G and Steiner, Benoit and Tucker, Paul and Vasudevan, Vijay and Warden, Pete and Wicke, Martin and Yu, Yuan and Zheng, Xiaoqiang},
  pages = {21},
  abstract = {TensorFlow is a machine learning system that operates at large scale and in heterogeneous environments. TensorFlow uses dataflow graphs to represent computation, shared state, and the operations that mutate that state. It maps the nodes of a dataflow graph across many machines in a cluster, and within a machine across multiple computational devices, including multicore CPUs, generalpurpose GPUs, and custom-designed ASICs known as Tensor Processing Units (TPUs). This architecture gives flexibility to the application developer: whereas in previous “parameter server” designs the management of shared state is built into the system, TensorFlow enables developers to experiment with novel optimizations and training algorithms. TensorFlow supports a variety of applications, with a focus on training and inference on deep neural networks. Several Google services use TensorFlow in production, we have released it as an open-source project, and it has become widely used for machine learning research. In this paper, we describe the TensorFlow dataflow model and demonstrate the compelling performance that TensorFlow achieves for several real-world applications.},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/4W9ZMGV6/Abadi et al. - TensorFlow A system for large-scale machine learn.pdf}
}

@article{abramsonALOHASYSTEMAnother,
  title = {{{THE ALOHA SYSTEM}}—{{Another}} Alternative for Computer Communications},
  author = {Abramson, Norman},
  pages = {6},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/FXJPRF68/Abramson - THE ALOHA SYSTEM—Another alternative for computer .pdf}
}

@article{andersonSchedulerActivationsEffective1991,
  title = {Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism},
  shorttitle = {Scheduler Activations},
  author = {Anderson, Thomas E. and Bershad, Brian N. and Lazowska, Edward D. and Levy, Henry M.},
  date = {1991-10-02},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {25},
  number = {5},
  pages = {95--109},
  issn = {0163-5980},
  doi = {10.1145/121133.121151},
  url = {https://dl.acm.org/doi/10.1145/121133.121151},
  urldate = {2021-11-16},
  abstract = {Threads               are the vehicle for concurrency in many approaches to parallel programming. Threads separate the notion of a sequential execution stream from the other aspects of traditional UNIX-like processes, such as address spaces and I/O descriptors. The objective of this separation is to make the expression and control of parallelism sufficiently cheap that the programmer or compiler can exploit even fine-grained parallelism with acceptable overhead.Threads can be supported either by the operating system kernel or by user-level library code in the application address space, but neither approach has been fully satisfactory. This paper addresses this dilemma. First, we argue that the performance of kernel threads is               inherently               worse than that of user-level threads, rather than this being an artifact of existing implementations; we thus argue that managing parallelism at the user level is essential to high-performance parallel computing. Next, we argue that the lack of system integration exhibited by user-level threads is a consequence of the lack of kernel support for user-level threads provided by contemporary multiprocessor operating systems; we thus argue that kernel threads or processes, as currently conceived, are the               wrong abstraction               on which to support user-level management of parallelism. Finally, we describe the design, implementation, and performance of a new kernel interface and user-level thread package that together provide the same functionality as kernel threads without compromising the performance and flexibility advantages of user-level management of parallelism.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/J8PBZR2N/scheduler.pdf}
}

@inproceedings{andrusCellsVirtualMobile2011,
  title = {Cells: A Virtual Mobile Smartphone Architecture},
  shorttitle = {Cells},
  booktitle = {Proceedings of the {{Twenty-Third ACM Symposium}} on {{Operating Systems Principles}} - {{SOSP}} '11},
  author = {Andrus, Jeremy and Dall, Christoffer and Hof, Alexander Van't and Laadan, Oren and Nieh, Jason},
  date = {2011},
  pages = {173},
  publisher = {{ACM Press}},
  location = {{Cascais, Portugal}},
  doi = {10.1145/2043556.2043574},
  url = {http://dl.acm.org/citation.cfm?doid=2043556.2043574},
  urldate = {2021-11-18},
  abstract = {Smartphones are increasingly ubiquitous, and many users carry multiple phones to accommodate work, personal, and geographic mobility needs. We present Cells, a virtualization architecture for enabling multiple virtual smartphones to run simultaneously on the same physical cellphone in an isolated, secure manner. Cells introduces a usage model of having one foreground virtual phone and multiple background virtual phones. This model enables a new device namespace mechanism and novel device proxies that integrate with lightweight operating system virtualization to multiplex phone hardware across multiple virtual phones while providing native hardware device performance. Cells virtual phone features include fully accelerated 3D graphics, complete power management features, and full telephony functionality with separately assignable telephone numbers and caller ID support. We have implemented a prototype of Cells that supports multiple Android virtual phones on the same phone. Our performance results demonstrate that Cells imposes only modest runtime and memory overhead, works seamlessly across multiple hardware devices including Google Nexus 1 and Nexus S phones, and transparently runs Android applications at native speed without any modifications.},
  eventtitle = {The {{Twenty-Third ACM Symposium}}},
  isbn = {978-1-4503-0977-6},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/MLLGFG3U/Andrus et al. - 2011 - Cells a virtual mobile smartphone architecture.pdf}
}

@article{avgerinosAutomaticExploitGeneration2014,
  title = {Automatic Exploit Generation},
  author = {Avgerinos, Thanassis and Cha, Sang Kil and Rebert, Alexandre and Schwartz, Edward J. and Woo, Maverick and Brumley, David},
  date = {2014-02},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {57},
  number = {2},
  pages = {74--84},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/2560217.2560219},
  url = {https://dl.acm.org/doi/10.1145/2560217.2560219},
  urldate = {2022-04-04},
  abstract = {The idea is to identify security-critical software bugs so they can be fixed first.},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/353EJSUR/Avgerinos et al. - 2014 - Automatic exploit generation.pdf}
}

@article{barhamXenArtVirtualization2003,
  title = {Xen and the Art of Virtualization},
  author = {Barham, Paul and Dragovic, Boris and Fraser, Keir and Hand, Steven and Harris, Tim and Ho, Alex and Neugebauer, Rolf and Pratt, Ian and Warfield, Andrew},
  date = {2003-12},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {37},
  number = {5},
  pages = {164--177},
  issn = {0163-5980},
  doi = {10.1145/1165389.945462},
  url = {https://dl.acm.org/doi/10.1145/1165389.945462},
  urldate = {2021-10-28},
  abstract = {Numerous systems have been designed which use virtualization to subdivide the ample resources of a modern computer. Some require specialized hardware, or cannot support commodity operating systems. Some target 100\% binary compatibility at the expense of performance. Others sacrifice security or functionality for speed. Few offer resource isolation or performance guarantees; most provide only best-effort provisioning, risking denial of service.This paper presents Xen, an x86 virtual machine monitor which allows multiple commodity operating systems to share conventional hardware in a safe and resource managed fashion, but without sacrificing either performance or functionality. This is achieved by providing an idealized virtual machine abstraction to which operating systems such as Linux, BSD and Windows XP, can be               ported               with minimal effort.Our design is targeted at hosting up to 100 virtual machine instances simultaneously on a modern server. The virtualization approach taken by Xen is extremely efficient: we allow operating systems such as Linux and Windows XP to be hosted simultaneously for a negligible performance overhead --- at most a few percent compared with the unvirtualized case. We considerably outperform competing commercial and freely available solutions in a range of microbenchmarks and system-wide tests.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/96A8NNDI/Barham et al. - 2003 - Xen and the art of virtualization.pdf}
}

@article{beaverFindingNeedleHaystack,
  title = {Finding a Needle in {{Haystack}}: {{Facebook}}’s Photo Storage},
  author = {Beaver, Doug and Kumar, Sanjeev and Li, Harry C and Sobel, Jason and Vajgel, Peter},
  pages = {14},
  abstract = {This paper describes Haystack, an object storage system optimized for Facebook’s Photos application. Facebook currently stores over 260 billion images, which translates to over 20 petabytes of data. Users upload one billion new photos (∼60 terabytes) each week and Facebook serves over one million images per second at peak. Haystack provides a less expensive and higher performing solution than our previous approach, which leveraged network attached storage appliances over NFS. Our key observation is that this traditional design incurs an excessive number of disk operations because of metadata lookups. We carefully reduce this per photo metadata so that Haystack storage machines can perform all metadata lookups in main memory. This choice conserves disk operations for reading actual data and thus increases overall throughput.},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/SVX958J3/Beaver et al. - Finding a needle in Haystack Facebook’s photo sto.pdf}
}

@article{bensoussanMulticsVirtualMemory1972,
  title = {The {{Multics}} Virtual Memory: Concepts and Design},
  shorttitle = {The {{Multics}} Virtual Memory},
  author = {Bensoussan, A. and Clingen, C. T. and Daley, R. C.},
  date = {1972-05},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {15},
  number = {5},
  pages = {308--318},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/355602.361306},
  url = {https://dl.acm.org/doi/10.1145/355602.361306},
  urldate = {2021-10-01},
  abstract = {As experience with use of on-line operating systems has grown, the need to share information among system users has become increasingly apparent. Many contemporary systems permit some degree of sharing. Usually, sharing is accomplished by allowing several users to share data via input and output of information stored in files kept in secondary storage. Through the use of segmentation, however, Multics provides direct hardware addressing by user and system programs of all information, independent of its physical storage location. Information is stored in segments each of which is potentially sharable and carries its own independent attributes of size and access privilege.             Here, the design and implementation considerations of segmentation and sharing in Multics are first discussed under the assumption that all information resides in a large, segmented main memory. Since the size of main memory on contemporary systems is rather limited, it is then shown how the Multics software achieves the effect of a large segmented main memory through the use of the Honeywell 645 segmentation and paging hardware.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/H7NH9YQU/Bensoussan et al. - 1972 - The Multics virtual memory concepts and design.pdf}
}

@inproceedings{bittauHackingBlind2014,
  title = {Hacking {{Blind}}},
  booktitle = {2014 {{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Bittau, Andrea and Belay, Adam and Mashtizadeh, Ali and Mazieres, David and Boneh, Dan},
  date = {2014-05},
  pages = {227--242},
  publisher = {{IEEE}},
  location = {{San Jose, CA}},
  doi = {10.1109/SP.2014.22},
  url = {http://ieeexplore.ieee.org/document/6956567/},
  urldate = {2022-03-31},
  eventtitle = {2014 {{IEEE Symposium}} on {{Security}} and {{Privacy}} ({{SP}})},
  isbn = {978-1-4799-4686-0},
  keywords = {cse227},
  file = {/Users/yuan/Zotero/storage/CPWXLD5G/Bittau et al. - 2014 - Hacking Blind.pdf}
}

@article{bobrowTENEXPagedTime1972,
  title = {{{TENEX}}, a Paged Time Sharing System for the {{PDP}} - 10},
  author = {Bobrow, Daniel G. and Burchfiel, Jerry D. and Murphy, Daniel L. and Tomlinson, Raymond S.},
  date = {1972-03},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {15},
  number = {3},
  pages = {135--143},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/361268.361271},
  url = {https://dl.acm.org/doi/10.1145/361268.361271},
  urldate = {2021-09-29},
  abstract = {TENEX is a new time sharing system implemented on a DEC PDP-10 augmented by special paging hardware developed at BBN. This report specifies a set of goals which are important for any time sharing system. It describes how the TENEX design and implementation achieve these goals. These include specifications for a powerful multiprocess large memory virtual machine, intimate terminal interaction, comprehensive uniform file and I/O capabilities, and clean flexible system structure. Although the implementation described here required some compromise to achieve a system operational within six months of hardware checkout, TENEX has met its major goals and provided reliable service at several sites and through the ARPA network.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/UAZQXP5L/Bobrow et al. - 1972 - TENEX, a paged time sharing system for the PDP - 1.pdf}
}

@article{cerfProtocolPacketNetwork1974,
  title = {A {{Protocol}} for {{Packet Network Intercommunication}}},
  author = {Cerf, Vinton G and Kahn, Robert E},
  date = {1974},
  number = {5},
  pages = {13},
  abstract = {A protocol that supports the sharing of resources that exist in different packet switching networks is presented. The protocol provides for variation in individual network packet sizes, transmission failures, sequencing, flow control, end-to-end error checking, and the creation and destruction of logical process-to-process connections. Some implementation issues are considered, and problems such as internetwork routing, accounting, and timeouts are exposed.},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/66Y7INW5/Cerf and Kahn - 1974 - A Protocol for Packet Network Intercommunication.pdf}
}

@article{changBigtableDistributedStorage2008,
  title = {Bigtable: {{A Distributed Storage System}} for {{Structured Data}}},
  shorttitle = {Bigtable},
  author = {Chang, Fay and Dean, Jeffrey and Ghemawat, Sanjay and Hsieh, Wilson C. and Wallach, Deborah A. and Burrows, Mike and Chandra, Tushar and Fikes, Andrew and Gruber, Robert E.},
  date = {2008-06},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {26},
  number = {2},
  pages = {1--26},
  issn = {0734-2071, 1557-7333},
  doi = {10.1145/1365815.1365816},
  url = {https://dl.acm.org/doi/10.1145/1365815.1365816},
  urldate = {2021-11-23},
  abstract = {Bigtable is a distributed storage system for managing structured data that is designed to scale to a very large size: petabytes of data across thousands of commodity servers. Many projects at Google store data in Bigtable, including web indexing, Google Earth, and Google Finance. These applications place very different demands on Bigtable, both in terms of data size (from URLs to web pages to satellite imagery) and latency requirements (from backend bulk processing to real-time data serving). Despite these varied demands, Bigtable has successfully provided a flexible, high-performance solution for all of these Google products. In this paper we describe the simple data model provided by Bigtable, which gives clients dynamic control over data layout and format, and we describe the design and implementation of Bigtable.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/XL2MHANJ/Chang et al. - 2008 - Bigtable A Distributed Storage System for Structu.pdf}
}

@inproceedings{chenRioFileCache1996,
  title = {The {{Rio}} File Cache: Surviving Operating System Crashes},
  shorttitle = {The {{Rio}} File Cache},
  booktitle = {Proceedings of the Seventh International Conference on {{Architectural}} Support for Programming Languages and Operating Systems  - {{ASPLOS-VII}}},
  author = {Chen, Peter M. and Ng, Wee Teck and Chandra, Subhachandra and Aycock, Christopher and Rajamani, Gurushankar and Lowell, David},
  date = {1996},
  pages = {74--83},
  publisher = {{ACM Press}},
  location = {{Cambridge, Massachusetts, United States}},
  doi = {10.1145/237090.237154},
  url = {http://portal.acm.org/citation.cfm?doid=237090.237154},
  urldate = {2021-11-09},
  eventtitle = {The Seventh International Conference},
  isbn = {978-0-89791-767-4},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/J9A6YXLJ/Chen et al. - 1996 - The Rio file cache surviving operating system cra.pdf}
}

@article{cheritonDistributedKernelIts1983,
  title = {The Distributed {{V}} Kernel and Its Performance for Diskless Workstations},
  author = {Cheriton, David R. and Zwaenepoel, Willy},
  date = {1983-12-31},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {17},
  number = {5},
  pages = {129--140},
  issn = {0163-5980},
  doi = {10.1145/773379.806621},
  url = {https://dl.acm.org/doi/10.1145/773379.806621},
  urldate = {2021-10-18},
  abstract = {The distributed V kernel is a message-oriented kernel that provides uniform local and network interprocess communication. It is primarily being used in an environment of diskless workstations connected by a high-speed local network to a set of file servers. We describe a performance evaluation of the kernel, with particular emphasis on the cost of network file access. Our results show that over a local network:             1. Diskless workstations can access remote files with minimal performance penalty.             2. The V message facility can be used to access remote files at comparable cost to any well-tuned specialized file access protocol.             We conclude that it is feasible to build a distributed system with all network communication using the V message facility even when most of the network nodes have no secondary storage.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/MIKBQB8C/Cheriton and Zwaenepoel - 1983 - The distributed V kernel and its performance for d.pdf}
}

@article{creasyOriginVM3701981,
  title = {The {{Origin}} of the {{VM}}/370 {{Time-Sharing System}}},
  author = {Creasy, R. J.},
  date = {1981-09},
  journaltitle = {IBM Journal of Research and Development},
  shortjournal = {IBM J. Res. \& Dev.},
  volume = {25},
  number = {5},
  pages = {483--490},
  issn = {0018-8646, 0018-8646},
  doi = {10.1147/rd.255.0483},
  url = {http://ieeexplore.ieee.org/document/5390583/},
  urldate = {2021-10-28},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/6WF5WMAC/Creasy - 1981 - The Origin of the VM370 Time-Sharing System.pdf}
}

@article{deanMapReduceSimplifiedData2008,
  title = {{{MapReduce}}: Simplified Data Processing on Large Clusters},
  shorttitle = {{{MapReduce}}},
  author = {Dean, Jeffrey and Ghemawat, Sanjay},
  date = {2008-01},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {51},
  number = {1},
  pages = {107--113},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/1327452.1327492},
  url = {https://dl.acm.org/doi/10.1145/1327452.1327492},
  urldate = {2021-11-30},
  abstract = {MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. Many real world tasks are expressible in this model, as shown in the paper.},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/5FFGLYVC/Dean and Ghemawat - 2008 - MapReduce simplified data processing on large clu.pdf}
}

@article{dijkstraStructureMultiprogrammingSystem1968,
  title = {The Structure of the “{{THE}}”-Multiprogramming System},
  author = {Dijkstra, Edsger W.},
  date = {1968-05},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {11},
  number = {5},
  pages = {341--346},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/363095.363143},
  url = {https://dl.acm.org/doi/10.1145/363095.363143},
  urldate = {2021-09-25},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/K4LCEQ9X/Dijkstra - 1968 - The structure of the “THE”-multiprogramming system.pdf}
}

@article{dolstraNixSafePolicyFree2004,
  title = {Nix: {{A Safe}} and {{Policy-Free System}} for {{Software Deployment}}},
  author = {Dolstra, Eelco and de Jonge, Merijn and Visser, Eelco},
  options = {useprefix=true},
  date = {2004},
  pages = {14},
  abstract = {Existing systems for software deployment are neither safe nor sufficiently flexible. Primary safety issues are the inability to enforce reliable specification of component dependencies, and the lack of support for multiple versions or variants of a component. This renders deployment operations such as upgrading or deleting components dangerous and unpredictable. A deployment system must also be flexible (i.e., policy-free) enough to support both centralised and local package management, and to allow a variety of mechanisms for transferring components. In this paper we present Nix, a deployment system that addresses these issues through a simple technique of using cryptographic hashes to compute unique paths for component instances.},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/XI32Y4GC/Dolstra et al. - 2004 - Nix A Safe and Policy-Free System for Software De.pdf}
}

@inproceedings{duanMeasuringSupplyChain2021,
  title = {Towards {{Measuring Supply Chain Attacks}} on {{Package Managers}} for {{Interpreted Languages}}},
  booktitle = {Proceedings 2021 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Duan, Ruian and Alrawi, Omar and Kasturi, Ranjita Pai and Elder, Ryan and Saltaformaggio, Brendan and Lee, Wenke},
  date = {2021},
  publisher = {{Internet Society}},
  location = {{Virtual}},
  doi = {10.14722/ndss.2021.23055},
  url = {https://www.ndss-symposium.org/wp-content/uploads/ndss2021_1B-1_23055_paper.pdf},
  urldate = {2022-04-11},
  eventtitle = {Network and {{Distributed System Security Symposium}}},
  isbn = {978-1-891562-66-2},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/KC9IH72A/Duan et al. - 2021 - Towards Measuring Supply Chain Attacks on Package .pdf}
}

@article{durumericZMapFastInternetwide,
  title = {{{ZMap}}: {{Fast Internet-wide Scanning}} and Its {{Security Applications}}},
  author = {Durumeric, Zakir and Wustrow, Eric and Halderman, J Alex},
  pages = {15},
  abstract = {Internet-wide network scanning has numerous security applications, including exposing new vulnerabilities and tracking the adoption of defensive mechanisms, but probing the entire public address space with existing tools is both difficult and slow. We introduce ZMap, a modular, open-source network scanner specifically architected to perform Internet-wide scans and capable of surveying the entire IPv4 address space in under 45 minutes from user space on a single machine, approaching the theoretical maximum speed of gigabit Ethernet. We present the scanner architecture, experimentally characterize its performance and accuracy, and explore the security implications of high speed Internet-scale network surveys, both offensive and defensive. We also discuss best practices for good Internet citizenship when performing Internet-wide surveys, informed by our own experiences conducting a long-term research survey over the past year.},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/ITGQW6BH/Durumeric et al. - ZMap Fast Internet-wide Scanning and its Security.pdf}
}

@article{enckTaintDroidInformationFlowTracking,
  title = {{{TaintDroid}}: {{An Information-Flow Tracking System}} for {{Realtime Privacy Monitoring}} on {{Smartphones}}},
  author = {Enck, William and Gilbert, Peter and Chun, Byung-Gon and Cox, Landon P and Jung, Jaeyeon and McDaniel, Patrick and Sheth, Anmol N},
  pages = {15},
  abstract = {Today’s smartphone operating systems frequently fail to provide users with adequate control over and visibility into how third-party applications use their private data. We address these shortcomings with TaintDroid, an efficient, system-wide dynamic taint tracking and analysis system capable of simultaneously tracking multiple sources of sensitive data. TaintDroid provides realtime analysis by leveraging Android’s virtualized execution environment. TaintDroid incurs only 14\% performance overhead on a CPU-bound micro-benchmark and imposes negligible overhead on interactive third-party applications. Using TaintDroid to monitor the behavior of 30 popular third-party Android applications, we found 68 instances of potential misuse of users’ private information across 20 applications. Monitoring sensitive data with TaintDroid provides informed use of third-party applications for phone users and valuable input for smartphone security service firms seeking to identify misbehaving applications.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/YE5SJ4IN/Enck et al. - TaintDroid An Information-Flow Tracking System fo.pdf}
}

@article{englerExokernelOperatingSystem1995,
  title = {Exokernel: An Operating System Architecture for Application-Level Resource Management},
  shorttitle = {Exokernel},
  author = {Engler, D. R. and Kaashoek, M. F. and O'Toole, J.},
  date = {1995-12-03},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {29},
  number = {5},
  pages = {251--266},
  issn = {0163-5980},
  doi = {10.1145/224057.224076},
  url = {https://dl.acm.org/doi/10.1145/224057.224076},
  urldate = {2021-10-26},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/9NYB6P6K/Engler et al. - 1995 - Exokernel an operating system architecture for ap.pdf}
}

@incollection{erlingssonLowLevelSoftwareSecurity2010,
  title = {Low-{{Level Software Security}} by {{Example}}},
  booktitle = {Handbook of {{Information}} and {{Communication Security}}},
  author = {Erlingsson, Úlfar and Younan, Yves and Piessens, Frank},
  editor = {Stavroulakis, Peter and Stamp, Mark},
  date = {2010},
  pages = {633--658},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-04117-4_30},
  url = {http://link.springer.com/10.1007/978-3-642-04117-4_30},
  urldate = {2022-03-31},
  isbn = {978-3-642-04116-7 978-3-642-04117-4},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/5V5VYRBT/Erlingsson et al. - 2010 - Low-Level Software Security by Example.pdf}
}

@article{feamsterCorrectnessPropertiesInternet,
  title = {Correctness {{Properties}} for {{Internet Routing}}},
  author = {Feamster, Nick and Balakrishnan, Hari},
  pages = {10},
  abstract = {This paper motivates and presents a correctness specification for Internet routing. This specification is based on three properties—route validity, path visibility, and safety. This specification may be of use to people developing tools to check routing configurations, to people designing solutions to specific problems in the current system, and to designers of new protocols and routing architectures, all of whom can benefit from knowing what it means for Internet routing to be “correct”.},
  langid = {english},
  keywords = {network},
  file = {/Users/yuan/Zotero/storage/N6RZIPI6/Feamster and Balakrishnan - Correctness Properties for Internet Routing.pdf}
}

@article{feamsterDetectingBGPConfiguration2005,
  title = {Detecting {{BGP Conﬁguration Faults}} with {{Static Analysis}}},
  author = {Feamster, Nick and Balakrishnan, Hari},
  date = {2005},
  journaltitle = {NSDI'05: Proceedings of the 2nd conference on Symposium on Networked Systems Design \& Implementation},
  volume = {2},
  pages = {43--56},
  doi = {10.5555/1251203.1251207},
  abstract = {The Internet is composed of many independent autonomous systems (ASes) that exchange reachability information to destinations using the Border Gateway Protocol (BGP). Network operators in each AS configure BGP routers to control the routes that are learned, selected, and announced to other routers. Faults in BGP configuration can cause forwarding loops, packet loss, and unintended paths between hosts, each of which constitutes a failure of the Internet routing infrastructure.},
  langid = {english},
  keywords = {network},
  file = {/Users/yuan/Zotero/storage/ANNBYUA4/Feamster and Balakrishnan - Detecting BGP Conﬁguration Faults with Static Anal.pdf}
}

@article{feamsterProactiveTechniquesCorrect,
  title = {Proactive {{Techniques}} for {{Correct}} and {{Predictable Internet Routing}}},
  author = {Feamster, Nicholas Greer},
  pages = {195},
  abstract = {The Internet is composed of thousands of autonomous, competing networks that exchange reachability information using an interdomain routing protocol. Network operators must continually reconfigure the routing protocols to realize various economic and performance goals. Unfortunately, there is no systematic way to predict how the configuration will affect the behavior of the routing protocol or to determine whether the routing protocol will operate correctly at all. This dissertation develops techniques to reason about the dynamic behavior of Internet routing, based on static analysis of the router configurations, before the protocol ever runs on a live network.},
  langid = {english},
  keywords = {network},
  file = {/Users/yuan/Zotero/storage/WYB43VT4/Feamster - Proactive Techniques for Correct and Predictable I.pdf}
}

@article{feeleyImplementingGlobalMemory1995,
  title = {Implementing Global Memory Management in a Workstation Cluster},
  author = {Feeley, M. J. and Morgan, W. E. and Pighin, E. P. and Karlin, A. R. and Levy, H. M. and Thekkath, C. A.},
  date = {1995-12-03},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {29},
  number = {5},
  pages = {201--212},
  issn = {0163-5980},
  doi = {10.1145/224057.224072},
  url = {https://dl.acm.org/doi/10.1145/224057.224072},
  urldate = {2021-10-21},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/RQW6F8RF/Feeley et al. - 1995 - Implementing global memory management in a worksta.pdf}
}

@article{floydDifficultiesSimulatingInternet2001,
  title = {Difficulties in Simulating the {{Internet}}},
  author = {Floyd, S. and Paxson, V.},
  year = {Aug./2001},
  journaltitle = {IEEE/ACM Transactions on Networking},
  shortjournal = {IEEE/ACM Trans. Networking},
  volume = {9},
  number = {4},
  pages = {392--403},
  issn = {10636692},
  doi = {10.1109/90.944338},
  url = {http://ieeexplore.ieee.org/document/944338/},
  urldate = {2022-01-19},
  abstract = {Simulating how the global Internet behaves is an immensely challenging undertaking because of the network’s great heterogeneity and rapid change. The heterogeneity ranges from the individual links that carry the network’s traffic, to the protocols that interoperate over the links, to the “mix” of different applications used at a site, to the levels of congestion seen on different links. We discuss two key strategies for developing meaningful simulations in the face of these difficulties: searching for invariants, and judiciously exploring the simulation parameter space. We finish with a brief look at a collaborative effort within the research community to develop a common network simulator.},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/T7MN7K9F/Floyd and Paxson - 2001 - Difficulties in simulating the Internet.pdf}
}

@article{gangerSoftUpdatesSolution2000,
  title = {Soft Updates: A Solution to the Metadata Update Problem in File Systems},
  shorttitle = {Soft Updates},
  author = {Ganger, Gregory R. and McKusick, Marshall Kirk and Soules, Craig A. N. and Patt, Yale N.},
  date = {2000-05},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {18},
  number = {2},
  pages = {127--153},
  issn = {0734-2071, 1557-7333},
  doi = {10.1145/350853.350863},
  url = {https://dl.acm.org/doi/10.1145/350853.350863},
  urldate = {2021-11-09},
  abstract = {Metadata updates, such as file creation and block allocation, have consistently been identified as a source of performance, integrity, security, and availability problems for file systems.               Soft updates               is an implementation technique for low-cost sequencing of fine-grained updates to write-back cache blocks. Using soft updates to track and enforce metadata update dependencies, a file system can safely use delayed writes for almost all file operations. This article describes soft updates, their incorporation into the 4.4BSD fast file system, and the resulting effects on the sytem. We show that a disk-based file system using soft updates achieves memory-based file system performance while providing stronger integrity and security guarantees than most disk-based file  systems. For workloads that frequently perform updates on metadata (such as creating and deleting files), this improves performance by more than a factor of two and up to a factor of 20 when compared to the conventional synchronous write approach and by 4-19\% when compared to an aggressive write-ahead logging approach. In addition, soft updates can improve file system availablity by relegating crash-recovery assistance (e.g., the               fsck               utility) to an optional and background role, reducing file system recovery time to less than one second.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/KUVNKUAI/Ganger et al. - 2000 - Soft updates a solution to the metadata update pr.pdf}
}

@article{gaoStableInternetRouting2001,
  title = {Stable {{Internet Routing Without Global Coordination}}},
  author = {Gao, Lixin and Rexford, Jennifer},
  date = {2001},
  volume = {9},
  number = {6},
  pages = {12},
  abstract = {The Border Gateway Protocol (BGP) allows an autonomous system (AS) to apply diverse local policies for selecting routes and propagating reachability information to other domains. However, BGP permits ASs to have conflicting policies that can lead to routing instability. This paper proposes a set of guidelines for an AS to follow in setting its routing policies, without requiring coordination with other ASs. Our approach exploits the Internet’s hierarchical structure and the commercial relationships between ASs to impose a partial order on the set of routes to each destination. The guidelines conform to conventional traffic-engineering practices of ISPs, and provide each AS with significant flexibility in selecting its local policies. Furthermore, the guidelines ensure route convergence even under changes in the topology and routing policies. Drawing on a formal model of BGP, we prove that following our proposed policy guidelines guarantees route convergence. We also describe how our methodology can be applied to new types of relationships between ASs, how to verify the hierarchical AS relationships, and how to realize our policy guidelines. Our approach has significant practical value since it preserves the ability of each AS to apply complex local policies without divulging its BGP configurations to others.},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/6XF92VBI/Gao and Rexford - 2001 - Stable Internet Routing Without Global Coordinatio.pdf}
}

@article{ghemawatGoogleFileSystem2003,
  title = {The {{Google}} File System},
  author = {Ghemawat, Sanjay and Gobioff, Howard and Leung, Shun-Tak},
  date = {2003-12},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {37},
  number = {5},
  pages = {29--43},
  issn = {0163-5980},
  doi = {10.1145/1165389.945450},
  url = {https://dl.acm.org/doi/10.1145/1165389.945450},
  urldate = {2021-11-23},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/L2ZY2V2Q/Ghemawat et al. - 2003 - The Google file system.pdf}
}

@article{goodellWorkingBGPIncremental2003,
  title = {Working {{Around BGP}}: {{An Incremental Approach}} to {{Improving Security}} and {{Accuracy}} of {{Interdomain Routing}}},
  author = {Goodell, Geoffrey and Aiello, William and Griffin, Timothy and Ioannidis, John and McDaniel, Patrick and Rubin, Aviel},
  date = {2003},
  journaltitle = {In Proc. NDSS},
  pages = {11},
  abstract = {BGP is essential to the operation of the Internet, but is vulnerable to both accidental failures and malicious attacks. We propose a new protocol that works in concert with BGP, which Autonomous Systems will use to help detect and mitigate accidentally or maliciously introduced faulty routing information. The protocol differs from previous efforts at securing BGP in that it is receiver-driven, meaning that there is a mechanism for recipients of BGP UPDATE messages to corroborate the information they receive and to provide feedback. We argue that our new protocol can be adopted incrementally, and we show that there is incentive for network operators to do so. We also describe our prototype implementation.},
  langid = {english},
  keywords = {network},
  file = {/Users/yuan/Zotero/storage/W4QTLGTK/Goodell et al. - Working Around BGP An Incremental Approach to Imp.pdf}
}

@article{grahamBoundsCertainMultiprocessing1966,
  title = {Bounds for {{Certain Multiprocessing Anomalies}}},
  author = {Graham, R. L.},
  date = {1966-11},
  journaltitle = {Bell System Technical Journal},
  volume = {45},
  number = {9},
  pages = {1563--1581},
  issn = {00058580},
  doi = {10.1002/j.1538-7305.1966.tb01709.x},
  url = {https://ieeexplore.ieee.org/document/6767827},
  urldate = {2021-12-05},
  langid = {english},
  keywords = {algorithm,cse202},
  file = {/Users/yuan/Zotero/storage/GSK5WDMH/69_02_multiprocessing.pdf}
}

@inproceedings{griffinDesignPrinciplesPolicy2003,
  title = {Design Principles of Policy Languages for Path Vector Protocols},
  booktitle = {Proceedings of the 2003 Conference on {{Applications}}, Technologies, Architectures, and Protocols for Computer Communications  - {{SIGCOMM}} '03},
  author = {Griffin, Timothy G. and Jaggard, Aaron D. and Ramachandran, Vijay},
  date = {2003},
  pages = {61},
  publisher = {{ACM Press}},
  location = {{Karlsruhe, Germany}},
  doi = {10.1145/863955.863964},
  url = {http://portal.acm.org/citation.cfm?doid=863955.863964},
  urldate = {2022-02-10},
  eventtitle = {The 2003 Conference},
  isbn = {978-1-58113-735-4},
  langid = {english},
  keywords = {network},
  file = {/Users/yuan/Zotero/storage/3MNPTWUW/Griffin et al. - 2003 - Design principles of policy languages for path vec.pdf}
}

@inproceedings{hanCodeAlchemistSemanticsAwareCode2019,
  title = {{{CodeAlchemist}}: {{Semantics-Aware Code Generation}} to {{Find Vulnerabilities}} in {{JavaScript Engines}}},
  shorttitle = {{{CodeAlchemist}}},
  booktitle = {Proceedings 2019 {{Network}} and {{Distributed System Security Symposium}}},
  author = {Han, HyungSeok and Oh, DongHyeon and Cha, Sang Kil},
  date = {2019},
  publisher = {{Internet Society}},
  location = {{San Diego, CA}},
  doi = {10.14722/ndss.2019.23263},
  url = {https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_05A-5_Han_paper.pdf},
  urldate = {2022-05-03},
  eventtitle = {Network and {{Distributed System Security Symposium}}},
  isbn = {978-1-891562-55-6},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/7VQD3S8S/Han et al. - 2019 - CodeAlchemist Semantics-Aware Code Generation to .pdf}
}

@article{hansenNucleusMultiprogrammingSystem1970,
  title = {The Nucleus of a Multiprogramming System},
  author = {Hansen, Per Brinch},
  date = {1970-04},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {13},
  number = {4},
  pages = {238--241},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/362258.362278},
  url = {https://dl.acm.org/doi/10.1145/362258.362278},
  urldate = {2021-09-25},
  abstract = {This paper describes the philosophy and structure of a multi-programming system that can be extended with a hierarchy of operating systems to suit diverse requirements of program scheduling and resource allocation. The system nucleus simulates an environment in which program execution and input/output are handled uniformly as parallel, cooperating processes. A fundamental set of primitives allows the dynamic creation and control of a hierarchy of processes as well as the communication among them.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/78WEUMM4/Hansen - 1970 - The nucleus of a multiprogramming system.pdf}
}

@article{hansenRC4000Realtime1967,
  title = {The {{RC}} 4000 Real-Time Control System at {{Pulawy}}},
  author = {Hansen, Per Brinch},
  date = {1967-12},
  journaltitle = {BIT},
  shortjournal = {BIT},
  volume = {7},
  number = {4},
  pages = {279--288},
  issn = {0006-3835, 1572-9125},
  doi = {10.1007/BF01939322},
  url = {http://link.springer.com/10.1007/BF01939322},
  urldate = {2021-09-27},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/DHTFEEG8/Hansen - 1967 - The RC 4000 real-time control system at Pulawy.pdf}
}

@article{hartigPerformanceMkernelbasedSystems1997,
  title = {The Performance of μ-Kernel-Based Systems},
  author = {Härtig, Hermann and Hohmuth, Michael and Liedtke, Jochen and Schönberg, Sebastian and Wolter, Jean},
  date = {1997-12},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {31},
  number = {5},
  pages = {66--77},
  issn = {0163-5980},
  doi = {10.1145/269005.266660},
  url = {https://dl.acm.org/doi/10.1145/269005.266660},
  urldate = {2021-10-26},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/HSKJULXQ/Härtig et al. - 1997 - The performance of μ-kernel-based systems.pdf}
}

@article{hartkeSurveyFreeMath,
  title = {A {{Survey}} of {{Free Math Fonts}} for {{TEX}} and {{LATEX}}},
  author = {Hartke, Stephen G},
  pages = {26},
  abstract = {We survey free math fonts for TEX and LATEX, with examples, instructions for using LATEX packages for changing fonts, and links to sources for the fonts and packages.},
  langid = {english},
  keywords = {tex},
  file = {/Users/yuan/Zotero/storage/TWZF4A8V/Hartke - A Survey of Free Math Fonts for TEX and LATEX.pdf}
}

@article{hoareMonitorsOperatingSystem1974,
  title = {Monitors: An Operating System Structuring Concept},
  shorttitle = {Monitors},
  author = {Hoare, C. A. R.},
  date = {1974-10},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {17},
  number = {10},
  pages = {549--557},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/355620.361161},
  url = {https://dl.acm.org/doi/10.1145/355620.361161},
  urldate = {2021-10-14},
  abstract = {This paper develops Brinch-Hansen's concept of a monitor as a method of structuring an operating system. It introduces a form of synchronization, describes a possible method of implementation in terms of semaphores and gives a suitable proof rule. Illustrative examples include a single resource scheduler, a bounded buffer, an alarm clock, a buffer pool, a disk head optimizer, and a version of the problem of readers and writers.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/3YFYXDI9/Hoare - 1974 - Monitors an operating system structuring concept.pdf}
}

@inproceedings{huSPVSecurePath2004,
  title = {{{SPV}}: Secure Path Vector Routing for Securing {{BGP}}},
  shorttitle = {{{SPV}}},
  booktitle = {Proceedings of the 2004 Conference on {{Applications}}, Technologies, Architectures, and Protocols for Computer Communications  - {{SIGCOMM}} '04},
  author = {Hu, Yih-Chun and Perrig, Adrian and Sirbu, Marvin},
  date = {2004},
  pages = {179},
  publisher = {{ACM Press}},
  location = {{Portland, Oregon, USA}},
  doi = {10.1145/1015467.1015488},
  url = {http://portal.acm.org/citation.cfm?doid=1015467.1015488},
  urldate = {2022-02-10},
  eventtitle = {The 2004 Conference},
  isbn = {978-1-58113-862-7},
  langid = {english},
  keywords = {network,secure BGP}
}

@article{karpDynamicProgrammingMeets1982,
  title = {Dynamic Programming Meets the Principle of Inclusion and Exclusion},
  author = {Karp, Richard M.},
  date = {1982-04},
  journaltitle = {Operations Research Letters},
  shortjournal = {Operations Research Letters},
  volume = {1},
  number = {2},
  pages = {49--51},
  issn = {01676377},
  doi = {10.1016/0167-6377(82)90044-X},
  url = {https://linkinghub.elsevier.com/retrieve/pii/016763778290044X},
  urldate = {2021-12-05},
  langid = {english},
  keywords = {algorithm,cse202}
}

@article{kentSecureBorderGateway2000,
  title = {Secure {{Border Gateway Protocol}} ({{S-BGP}})},
  author = {Kent, S. and Lynn, C. and Seo, K.},
  date = {2000-04},
  journaltitle = {IEEE Journal on Selected Areas in Communications},
  shortjournal = {IEEE J. Select. Areas Commun.},
  volume = {18},
  number = {4},
  pages = {582--592},
  issn = {0733-8716},
  doi = {10.1109/49.839934},
  url = {http://ieeexplore.ieee.org/document/839934/},
  urldate = {2022-02-10},
  keywords = {network,secure BGP}
}

@article{lampsonExperienceProcessesMonitors1980,
  title = {Experience with Processes and Monitors in {{Mesa}}},
  author = {Lampson, Butler W. and Redell, David D.},
  date = {1980-02},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {23},
  number = {2},
  pages = {105--117},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/358818.358824},
  url = {https://dl.acm.org/doi/10.1145/358818.358824},
  urldate = {2021-10-14},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/I4F7IUIV/Lampson and Redell - 1980 - Experience with processes and monitors in Mesa.pdf}
}

@article{lampsonProtection1974,
  title = {Protection},
  author = {Lampson, Butler W.},
  date = {1974-01},
  journaltitle = {ACM SIGOPS Operating Systems Review},
  shortjournal = {SIGOPS Oper. Syst. Rev.},
  volume = {8},
  number = {1},
  pages = {18--24},
  issn = {0163-5980},
  doi = {10.1145/775265.775268},
  url = {https://dl.acm.org/doi/10.1145/775265.775268},
  urldate = {2021-10-01},
  abstract = {Abstract models are given which reflect the properties of most existing mechanisms for enforcing protection or access control, together with some possible implementations. The properties of existing systems are explicated in terms of the model and implementations.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/PP49Z4TS/Lampson - 1974 - Protection.pdf}
}

@inproceedings{leeTamingUndefinedBehavior2017,
  title = {Taming Undefined Behavior in {{LLVM}}},
  booktitle = {Proceedings of the 38th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Lee, Juneyoung and Kim, Yoonseung and Song, Youngju and Hur, Chung-Kil and Das, Sanjoy and Majnemer, David and Regehr, John and Lopes, Nuno P.},
  date = {2017-06-14},
  pages = {633--647},
  publisher = {{ACM}},
  location = {{Barcelona Spain}},
  doi = {10.1145/3062341.3062343},
  url = {https://dl.acm.org/doi/10.1145/3062341.3062343},
  urldate = {2022-04-06},
  eventtitle = {{{PLDI}} '17: {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  isbn = {978-1-4503-4988-8},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/HVRBZS8C/Lee et al. - 2017 - Taming undefined behavior in LLVM.pdf}
}

@inproceedings{leMineralsUsingData2006,
  title = {Minerals: Using Data Mining to Detect Router Misconfigurations},
  shorttitle = {Minerals},
  booktitle = {Proceedings of the 2006 {{SIGCOMM}} Workshop on {{Mining}} Network Data  - {{MineNet}} '06},
  author = {Le, Franck and Lee, Sihyung and Wong, Tina and Kim, Hyong S. and Newcomb, Darrell},
  date = {2006},
  pages = {293--298},
  publisher = {{ACM Press}},
  location = {{Pisa, Italy}},
  doi = {10.1145/1162678.1162681},
  url = {http://portal.acm.org/citation.cfm?doid=1162678.1162681},
  urldate = {2022-02-10},
  eventtitle = {The 2006 {{SIGCOMM}} Workshop},
  isbn = {978-1-59593-569-4},
  langid = {english}
}

@misc{levinthalPerformanceAnalysisGuide,
  title = {Performance {{Analysis Guide}} for {{Intel}}® {{CoreTM}} I7 {{Processor}} and {{Intel}}® {{XeonTM}} 5500 Processors},
  author = {Levinthal, David},
  publisher = {{Intel Corporation}},
  url = {http://software.intel.com/sites/products/collateral/hpc/vtune/performance_analysis_guide.pdf},
  file = {/Users/yuan/Zotero/storage/WTXY429X/performance_analysis_guide.pdf}
}

@article{liMemoryCoherenceShared1989,
  title = {Memory Coherence in Shared Virtual Memory Systems},
  author = {Li, Kai and Hudak, Paul},
  date = {1989-11},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {7},
  number = {4},
  pages = {321--359},
  issn = {0734-2071, 1557-7333},
  doi = {10.1145/75104.75105},
  url = {https://dl.acm.org/doi/10.1145/75104.75105},
  urldate = {2022-03-30},
  abstract = {The memory coherence problem in designing and implementing a shared virtual memory on loosely coupled multiprocessors is studied in depth. Two classes of algorithms, centralized and distributed, for solving the problem are presented. A prototype shared virtual memory on an Apollo ring based on these algorithms has been implemented. Both theoretical and practical results show that the memory coherence problem can indeed be solved efficiently on a loosely coupled multiprocessor.},
  langid = {english},
  keywords = {cse223},
  file = {/Users/yuan/Zotero/storage/VEG83TBR/Li and Hudak - 1989 - Memory coherence in shared virtual memory systems.pdf}
}

@inproceedings{liskovReplicationHarpFile1991,
  title = {Replication in the Harp File System},
  booktitle = {Proceedings of the Thirteenth {{ACM}} Symposium on {{Operating}} Systems Principles  - {{SOSP}} '91},
  author = {Liskov, Barbara and Ghemawat, Sanjay and Gruber, Robert and Johnson, Paul and Shrira, Liuba},
  date = {1991},
  pages = {226--238},
  publisher = {{ACM Press}},
  location = {{Pacific Grove, California, United States}},
  doi = {10.1145/121132.121169},
  url = {http://portal.acm.org/citation.cfm?doid=121132.121169},
  urldate = {2022-04-14},
  eventtitle = {The Thirteenth {{ACM}} Symposium},
  isbn = {978-0-89791-447-5},
  langid = {english},
  keywords = {cse223,distributed,system},
  file = {/Users/yuan/Zotero/storage/5KIJJGIC/Liskov et al. - 1991 - Replication in the harp file system.pdf}
}

@inproceedings{mahajanUnderstandingBGPMisconfiguration2002,
  title = {Understanding {{BGP}} Misconfiguration},
  booktitle = {Proceedings of the 2002 Conference on {{Applications}}, Technologies, Architectures, and Protocols for Computer Communications  - {{SIGCOMM}} '02},
  author = {Mahajan, Ratul and Wetherall, David and Anderson, Tom},
  date = {2002},
  pages = {3},
  publisher = {{ACM Press}},
  location = {{Pittsburgh, Pennsylvania, USA}},
  doi = {10.1145/633025.633027},
  url = {http://portal.acm.org/citation.cfm?doid=633025.633027},
  urldate = {2022-02-10},
  eventtitle = {The 2002 Conference},
  isbn = {978-1-58113-570-1},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/SYAVBUA6/Mahajan et al. - Understanding BGP Misconﬁguration.pdf}
}

@article{mckusickFastFileSystem1984,
  title = {A Fast File System for {{UNIX}}},
  author = {McKusick, Marshall K. and Joy, William N. and Leffler, Samuel J. and Fabry, Robert S.},
  date = {1984-08},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {2},
  number = {3},
  pages = {181--197},
  issn = {0734-2071, 1557-7333},
  doi = {10.1145/989.990},
  url = {https://dl.acm.org/doi/10.1145/989.990},
  urldate = {2021-11-04},
  langid = {english},
  keywords = {cse220,system},
  file = {/Users/yuan/Zotero/storage/26DIFUKZ/McKusick et al. - 1984 - A fast file system for UNIX.pdf}
}

@article{mcvoyLmbenchPortableTools,
  title = {Lmbench: {{Portable Tools}} for {{Performance Analysis}}},
  author = {McVoy, Larry and Staelin, Carl},
  journaltitle = {Proceedings of the 1996 Annual Conference on USENIX Annual Technical Conference},
  series = {{{ATEC}} '96},
  pages = {23},
  abstract = {lmbench is a micro-benchmark suite designed to focus attention on the basic building blocks of many common system applications, such as databases, simulations, software development, and networking. In almost all cases, the individual tests are the result of analysis and isolation of a customer's actual performance problem. These tools can be, and currently are, used to compare different system implementations from different vendors. In several cases, the benchmarks have uncovered previously unknown bugs and design flaws. The results have shown a strong correlation between memory system performance and overall performance. lmbench includes an extensible database of results from systems current as of late 1995.},
  langid = {english},
  keywords = {benchmark,cse221,system},
  file = {/Users/yuan/Zotero/storage/89YYMQ76/McVoy et al. - lmbench Portable Tools for Performance Analysis.pdf}
}

@article{mytkowiczProducingWrongData2009,
  title = {Producing Wrong Data without Doing Anything Obviously Wrong!},
  author = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
  date = {2009-02-28},
  journaltitle = {ACM SIGPLAN Notices},
  shortjournal = {SIGPLAN Not.},
  volume = {44},
  number = {3},
  pages = {265--276},
  issn = {0362-1340, 1558-1160},
  doi = {10.1145/1508284.1508275},
  url = {https://dl.acm.org/doi/10.1145/1508284.1508275},
  urldate = {2021-10-03},
  abstract = {This paper presents a surprising result: changing a seemingly innocuous aspect of an experimental setup can cause a systems researcher to draw wrong conclusions from an experiment. What appears to be an innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation. This phenomenon is called measurement bias in the natural and social sciences.             Our results demonstrate that measurement bias is significant and commonplace in computer system evaluation. By significant we mean that measurement bias can lead to a performance analysis that either over-states an effect or even yields an incorrect conclusion. By commonplace we mean that measurement bias occurs in all architectures that we tried (Pentium 4, Core 2, and m5 O3CPU), both compilers that we tried (gcc and Intel's C compiler), and most of the SPEC CPU2006 C programs. Thus, we cannot ignore measurement bias. Nevertheless, in a literature survey of 133 recent papers from ASPLOS, PACT, PLDI, and CGO, we determined that none of the papers with experimental results adequately consider measurement bias.             Inspired by similar problems and their solutions in other sciences, we describe and demonstrate two methods, one for detecting (causal analysis) and one for avoiding (setup randomization) measurement bias.},
  langid = {english},
  keywords = {strange loops,system},
  file = {/Users/yuan/Zotero/storage/K7RBZN3N/Mytkowicz et al. - Producing Wrong Data Without Doing Anything Obviou.pdf}
}

@inproceedings{Narayan2021SwivelHW,
  title = {Swivel: {{Hardening WebAssembly}} against Spectre},
  booktitle = {{{USENIX}} Security Symposium},
  author = {Narayan, Shravan and Disselkoen, Craig and Moghimi, Daniel and Cauligi, Sunjay and Johnson, Evan and Gang, Zhao and Vahldiek-Oberwagner, Anjo and Sahita, Ravi and Shacham, Hovav and Tullsen, Dean M. and Stefan, Deian},
  date = {2021},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/JD4IMAKU/Narayan et al. - 2021 - Swivel Hardening WebAssembly against spectre.pdf}
}

@article{oorschotInterdomainRoutingSecurity2007,
  title = {On Interdomain Routing Security and Pretty Secure {{BGP}} ({{psBGP}})},
  author = {van Oorschot, P.C. and Wan, Tao and Kranakis, Evangelos},
  date = {2007-07},
  journaltitle = {ACM Transactions on Information and System Security},
  shortjournal = {ACM Trans. Inf. Syst. Secur.},
  volume = {10},
  number = {3},
  pages = {11},
  issn = {1094-9224, 1557-7406},
  doi = {10.1145/1266977.1266980},
  url = {https://dl.acm.org/doi/10.1145/1266977.1266980},
  urldate = {2022-02-10},
  abstract = {It is well known that the Border Gateway Protocol (BGP), the IETF standard interdomain routing protocol, is vulnerable to a variety of attacks, and that a single misconfigured or malicious BGP speaker could result in large-scale service disruption. In this paper, we present               Pretty Secure BGP (psBGP)               ---a proposal for securing BGP, including an architectural overview, design details for significant aspects, and preliminary security and operational analysis. psBGP differs from other security proposals (e.g., S-BGP and soBGP) in that it makes use of a single-level PKI for AS number authentication, a decentralized trust model for verifying the propriety of IP prefix origin, and a rating-based stepwise approach for AS\_PATH (integrity) verification. psBGP trades off the strong security guarantees of S-BGP for presumed-simpler operation, e.g., using a PKI with a simple structure, with a small number of certificate types, and of manageable size. psBGP is designed to successfully defend against various (nonmalicious and malicious) threats from uncoordinated BGP speakers, and to be incrementally deployed with incremental benefits.},
  langid = {english},
  keywords = {network,secure BGP},
  file = {/Users/yuan/Zotero/storage/KAVNIXEV/Oorschot et al. - 2007 - On interdomain routing security and pretty secure .pdf}
}

@article{ousterhoutMedusaExperimentDistributed1980,
  title = {Medusa: An Experiment in Distributed Operating System Structure},
  shorttitle = {Medusa},
  author = {Ousterhout, John K. and Scelza, Donald A. and Sindhu, Pradeep S.},
  date = {1980-02},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {23},
  number = {2},
  pages = {92--105},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/358818.358823},
  url = {https://dl.acm.org/doi/10.1145/358818.358823},
  urldate = {2021-10-11},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/66GL95DQ/Ousterhout et al. - 1980 - Medusa an experiment in distributed operating sys.pdf}
}

@article{ousterhoutSpriteNetworkOperating1988,
  title = {The {{Sprite}} Network Operating System},
  author = {Ousterhout, J.K. and Cherenson, A.R. and Douglis, F. and Nelson, M.N. and Welch, B.B.},
  date = {1988-02},
  journaltitle = {Computer},
  shortjournal = {Computer},
  volume = {21},
  number = {2},
  pages = {23--36},
  issn = {0018-9162},
  doi = {10.1109/2.16},
  url = {http://ieeexplore.ieee.org/document/16/},
  urldate = {2021-10-18},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/XMLJUEGI/Ousterhout et al. - 1988 - The Sprite network operating system.pdf}
}

@misc{paoloniHowBenchmarkCode2010,
  title = {How to {{Benchmark Code Execution Times}} on {{Intel}}® {{IA-32}} and {{IA-64 Instruction Set Architectures}}},
  author = {Paoloni, Gabriele},
  date = {2010-09},
  publisher = {{Intel Corporation}},
  abstract = {This paper provides precise methods to measure the clock cycles spent when executing a certain C code on a Linux* environment with a generic Intel architecture processor (either 32 bits or 64 bits).},
  file = {/Users/yuan/Zotero/storage/YJA5WUF2/Paoloni - 2010 - How to Benchmark Code Execution Times on Intel® IA.pdf}
}

@article{paxsonEndtoEndRoutingBehavior,
  title = {End-to-{{End Routing Behavior}} in the {{Internet}}},
  author = {Paxson, Vern},
  pages = {14},
  abstract = {The large-scale behavior of routing in the Internet has gone virtually without any formal study, the exception being Chinoy's analysis of the dynamics of Internet routing information [Ch93]. We report on an analysis of 40,000 end-to-end route measurements conducted using repeated “traceroutes” between 37 Internet sites. We analyze the routing behavior for pathological conditions, routing stability, and routing symmetry. For pathologies, we characterize the prevalence of routing loops, erroneous routing, infrastructure failures, and temporary outages. We find that the likelihood of encountering a major routing pathology more than doubled between the end of 1994 and the end of 1995, rising from 1.5\% to 3.4\%. For routing stability, we define two separate types of stability, “prevalence,” meaning the overall likelihood that a particular route is encountered, and “persistence,” the likelihood that a route remains unchanged over a long period of time. We find that Internet paths are heavily dominated by a single prevalent route, but that the time periods over which routes persist show wide variation, ranging from seconds up to days. About 2/3's of the Internet paths had routes persisting for either days or weeks. For routing symmetry, we look at the likelihood that a path through the Internet visits at least one different city in the two directions. At the end of 1995, this was the case half the time, and at least one different autonomous system was visited 30\% of the time.},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/2GJ82ACD/Paxson - End-to-End Routing Behavior in the Internet.pdf}
}

@inproceedings{paxsonStrategiesSoundInternet2004,
  title = {Strategies for Sound Internet Measurement},
  booktitle = {Proceedings of the 4th {{ACM SIGCOMM}} Conference on {{Internet}} Measurement  - {{IMC}} '04},
  author = {Paxson, Vern},
  date = {2004},
  pages = {263},
  publisher = {{ACM Press}},
  location = {{Taormina, Sicily, Italy}},
  doi = {10.1145/1028788.1028824},
  url = {http://portal.acm.org/citation.cfm?doid=1028788.1028824},
  urldate = {2022-01-19},
  eventtitle = {The 4th {{ACM SIGCOMM}} Conference},
  isbn = {978-1-58113-821-4},
  langid = {english},
  keywords = {cse222,network},
  file = {/Users/yuan/Zotero/storage/RZ9GQCAU/soundmeasurement.pdf}
}

@article{redellPilotOperatingSystem1980,
  title = {Pilot: An Operating System for a Personal Computer},
  shorttitle = {Pilot},
  author = {Redell, David D. and Dalal, Yogen K. and Horsley, Thomas R. and Lauer, Hugh C. and Lynch, William C. and McJones, Paul R. and Murray, Hal G. and Purcell, Stephen C.},
  date = {1980-02},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {23},
  number = {2},
  pages = {81--92},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/358818.358822},
  url = {https://dl.acm.org/doi/10.1145/358818.358822},
  urldate = {2021-10-11},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/JBN2NJHX/Redell et al. - 1980 - Pilot an operating system for a personal computer.pdf}
}

@article{reordaErrorDetectionSelfRepairingMethod2017,
  title = {An {{Error-Detection}} and {{Self-Repairing Method}} for {{Dynamically}} and {{Partially Reconfigurable Systems}}},
  author = {Reorda, Matteo Sonza and Sterpone, Luca and Ullah, Anees},
  date = {2017-06-01},
  journaltitle = {IEEE Transactions on Computers},
  shortjournal = {IEEE Trans. Comput.},
  volume = {66},
  number = {6},
  pages = {1022--1033},
  issn = {0018-9340},
  doi = {10.1109/TC.2016.2607749},
  url = {http://ieeexplore.ieee.org/document/7563888/},
  urldate = {2022-02-10},
  abstract = {Reconfigurable systems are gaining an increasing interest in the domain of safety-critical applications, for example in the space and avionic domains. In fact, the capability of reconfiguring the system during run-time execution and the high computational power of modern Field Programmable Gate Arrays (FPGAs) make these devices suitable for intensive data processing tasks. Moreover, such systems must also guarantee the abilities of self-awareness, self-diagnosis and self-repair in order to cope with errors due to the harsh conditions typically existing in some environments. In this paper we propose a selfrepairing method for partially and dynamically reconfigurable systems applied at a fine-grain granularity level. Our method is able to detect, correct and recover errors using the run-time capabilities offered by modern SRAM-based FPGAs. Fault injection campaigns have been executed on a dynamically reconfigurable system embedding a number of benchmark circuits. Experimental results demonstrate that our method achieves full detection of single and multiple errors, while significantly improving the system availability with respect to traditional error detection and correction methods.},
  file = {/Users/yuan/Zotero/storage/QG5WA9WD/Reorda et al. - 2017 - An Error-Detection and Self-Repairing Method for D.pdf}
}

@article{ritchieUNIXTimesharingSystem1974,
  title = {The {{UNIX}} Time-Sharing System},
  author = {Ritchie, Dennis M. and Thompson, Ken},
  date = {1974-07},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {17},
  number = {7},
  pages = {365--375},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/361011.361061},
  url = {https://dl.acm.org/doi/10.1145/361011.361061},
  urldate = {2021-10-06},
  abstract = {UNIX is a general-purpose, multi-user, interactive operating system for the Digital Equipment Corporation PDP-11/40 and 11/45 computers. It offers a number of features seldom found even in larger operating systems, including: (1) a hierarchical file system incorporating demountable volumes; (2) compatible file, device, and inter-process I/O; (3) the ability to initiate asynchronous processes; (4) system command language selectable on a per-user basis; and (5) over 100 subsystems including a dozen languages. This paper discusses the nature and implementation of the file system and of the user command interface.},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/V45WCA5J/Ritchie and Thompson - 1974 - The UNIX time-sharing system.pdf}
}

@article{roemerReturnOrientedProgrammingSystems2012,
  title = {Return-{{Oriented Programming}}: {{Systems}}, {{Languages}}, and {{Applications}}},
  shorttitle = {Return-{{Oriented Programming}}},
  author = {Roemer, Ryan and Buchanan, Erik and Shacham, Hovav and Savage, Stefan},
  date = {2012-03},
  journaltitle = {ACM Transactions on Information and System Security},
  shortjournal = {ACM Trans. Inf. Syst. Secur.},
  volume = {15},
  number = {1},
  pages = {1--34},
  issn = {1094-9224, 1557-7406},
  doi = {10.1145/2133375.2133377},
  url = {https://dl.acm.org/doi/10.1145/2133375.2133377},
  urldate = {2022-03-31},
  abstract = {We introduce               return-oriented programming               , a technique by which an attacker can induce arbitrary behavior in a program whose control flow he has diverted, without injecting any code. A return-oriented program chains together short instruction sequences already present in a program’s address space, each of which ends in a “return” instruction.                          Return-oriented programming defeats the W⊕X protections recently deployed by Microsoft, Intel, and AMD; in this context, it can be seen as a generalization of traditional return-into-libc attacks. But the threat is more general. Return-oriented programming is readily exploitable on multiple architectures and systems. It also bypasses an entire category of security measures---those that seek to prevent malicious computation by preventing the execution of malicious code.             To demonstrate the wide applicability of return-oriented programming, we construct a Turing-complete set of building blocks called gadgets using the standard C libraries of two very different architectures: Linux/x86 and Solaris/SPARC. To demonstrate the power of return-oriented programming, we present a high-level, general-purpose language for describing return-oriented exploits and a compiler that translates it to gadgets.},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/QYW9EKV2/Roemer et al. - 2012 - Return-Oriented Programming Systems, Languages, a.pdf}
}

@inproceedings{rosenblumDesignImplementationLogstructured1991,
  title = {The Design and Implementation of a Log-Structured File System},
  booktitle = {Proceedings of the Thirteenth {{ACM}} Symposium on {{Operating}} Systems Principles  - {{SOSP}} '91},
  author = {Rosenblum, Mendel and Ousterhout, John K.},
  date = {1991},
  pages = {1--15},
  publisher = {{ACM Press}},
  location = {{Pacific Grove, California, United States}},
  doi = {10.1145/121132.121137},
  url = {http://portal.acm.org/citation.cfm?doid=121132.121137},
  urldate = {2021-11-04},
  eventtitle = {The Thirteenth {{ACM}} Symposium},
  isbn = {978-0-89791-447-5},
  langid = {english},
  keywords = {cse220,system},
  file = {/Users/yuan/Zotero/storage/ZJERSJIE/Rosenblum and Ousterhout - 1991 - The design and implementation of a log-structured .pdf}
}

@incollection{rowstronPastryScalableDecentralized2001,
  title = {Pastry: {{Scalable}}, {{Decentralized Object Location}}, and {{Routing}} for {{Large-Scale Peer-to-Peer Systems}}},
  shorttitle = {Pastry},
  booktitle = {Middleware 2001},
  author = {Rowstron, Antony and Druschel, Peter},
  editor = {Guerraoui, Rachid},
  options = {useprefix=true},
  date = {2001},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {2218},
  pages = {329--350},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  doi = {10.1007/3-540-45518-3_18},
  url = {http://link.springer.com/10.1007/3-540-45518-3_18},
  urldate = {2022-02-09},
  abstract = {This paper presents the design and evaluation of Pastry, a scalable, distributed object location and routing substrate for wide-area peer-to-peer applications. Pastry performs application-level routing and object location in a potentially very large overlay network of nodes connected via the Internet. It can be used to support a variety of peer-to-peer applications, including global data storage, data sharing, group communication and naming.},
  editorb = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan},
  editorbtype = {redactor},
  isbn = {978-3-540-42800-8 978-3-540-45518-9},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/VYE8YDKY/Rowstron and Druschel - 2001 - Pastry Scalable, Decentralized Object Location, a.pdf}
}

@article{saltzerEndtoendArgumentsSystem1984,
  title = {End-to-End Arguments in System Design},
  author = {Saltzer, J. H. and Reed, D. P. and Clark, D. D.},
  date = {1984-11},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {2},
  number = {4},
  pages = {277--288},
  issn = {0734-2071, 1557-7333},
  doi = {10.1145/357401.357402},
  url = {https://dl.acm.org/doi/10.1145/357401.357402},
  urldate = {2022-01-03},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/SJUEM68H/Saltzer et al. - 1984 - End-to-end arguments in system design.pdf}
}

@article{saltzerProtectionControlInformation1974,
  title = {Protection and the Control of Information Sharing in Multics},
  author = {Saltzer, Jerome H.},
  date = {1974-07},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {17},
  number = {7},
  pages = {388--402},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/361011.361067},
  url = {https://dl.acm.org/doi/10.1145/361011.361067},
  urldate = {2021-10-01},
  abstract = {The design of mechanisms to control the sharing of information in the Multics system is described. Five design principles help provide insight into the tradeoffs among different possible designs. The key mechanisms described include access control lists, hierarchical control of access specifications, identification and authentication of users, and primary memory protection. The paper ends with a discussion of several known weaknesses in the current protection mechanism design.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/N2I2IHFA/Saltzer - 1974 - Protection and the control of information sharing .pdf}
}

@article{schroederExperienceGrapevineGrowth1984,
  title = {Experience with {{Grapevine}}: The Growth of a Distributed System},
  shorttitle = {Experience with {{Grapevine}}},
  author = {Schroeder, Michael D. and Birrell, Andrew D. and Needham, Roger M.},
  date = {1984-02},
  journaltitle = {ACM Transactions on Computer Systems},
  shortjournal = {ACM Trans. Comput. Syst.},
  volume = {2},
  number = {1},
  pages = {3--23},
  issn = {0734-2071, 1557-7333},
  doi = {10.1145/2080.2081},
  url = {https://dl.acm.org/doi/10.1145/2080.2081},
  urldate = {2021-10-21},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/RZ5QR6NC/Schroeder et al. - 1984 - Experience with Grapevine the growth of a distrib.pdf;/Users/yuan/Zotero/storage/YW79DCUE/Schroeder et al. - 1984 - Experience with Grapevine the growth of a distrib.pdf}
}

@article{sobrinhoAlgebraicTheoryDynamic2005,
  title = {An Algebraic Theory of Dynamic Network Routing},
  author = {Sobrinho, J.L.},
  date = {2005-10},
  journaltitle = {IEEE/ACM Transactions on Networking},
  shortjournal = {IEEE/ACM Trans. Networking},
  volume = {13},
  number = {5},
  pages = {1160--1173},
  issn = {1063-6692},
  doi = {10.1109/TNET.2005.857111},
  url = {http://ieeexplore.ieee.org/document/1528502/},
  urldate = {2022-02-10},
  keywords = {network}
}

@article{stanifordHow0wnInternet,
  title = {How to 0wn the {{Internet}} in {{Your Spare Time}}},
  author = {Staniford, Stuart and Paxton, Vern and Weaver, Nicholas},
  pages = {20},
  langid = {english},
  keywords = {cse222a,network},
  file = {/Users/yuan/Zotero/storage/UAK3NA7E/Staniford et al. - How to 0wn the Internet in Your Spare Time.pdf}
}

@article{szaboConversionTEXFonts,
  title = {Conversion of {{TEX}} Fonts into {{Type}} 1 Format},
  author = {Szabo, Peter},
  pages = {15},
  langid = {english},
  keywords = {tex},
  file = {/Users/yuan/Zotero/storage/3MH7SQBS/Szabo - Conversion of TEX fonts into Type 1 format.pdf}
}

@article{waldspurgerLotterySchedulingFlexible,
  title = {Lottery {{Scheduling}}: {{Flexible Proportional-Share Resource Management}}},
  author = {Waldspurger, Carl A and Weihl, William E},
  pages = {11},
  abstract = {This paper presents lottery scheduling, a novel randomized resource allocation mechanism. Lottery scheduling provides efficient, responsive control over the relative execution rates of computations. Such control is beyond the capabilities of conventional schedulers, and is desirable in systems that service requests of varying importance, such as databases, media-based applications, and networks. Lottery scheduling also supports modular resource management by enabling concurrent modules to insulate their resource allocation policies from one another. A currency abstraction is introduced to flexibly name, share, and protect resource rights. We also show that lottery scheduling can be generalized to manage many diverse resources, such as I/O bandwidth, memory, and access to locks. We have implemented a prototype lottery scheduler for the Mach 3.0 microkernel, and found that it provides flexible and responsive control over the relative execution rates of a wide range of applications. The overhead imposed by our unoptimized prototype is comparable to that of the standard Mach timesharing policy.},
  langid = {english},
  file = {/Users/yuan/Zotero/storage/BK5L5GYR/Waldspurger and Weihl - Lottery Scheduling Flexible Proportional-Share Re.pdf}
}

@inproceedings{wangOptimizationsafeSystemsAnalyzing2013,
  title = {Towards Optimization-Safe Systems: Analyzing the Impact of Undefined Behavior},
  shorttitle = {Towards Optimization-Safe Systems},
  booktitle = {Proceedings of the {{Twenty-Fourth ACM Symposium}} on {{Operating Systems Principles}}},
  author = {Wang, Xi and Zeldovich, Nickolai and Kaashoek, M. Frans and Solar-Lezama, Armando},
  date = {2013-11-03},
  pages = {260--275},
  publisher = {{ACM}},
  location = {{Farminton Pennsylvania}},
  doi = {10.1145/2517349.2522728},
  url = {https://dl.acm.org/doi/10.1145/2517349.2522728},
  urldate = {2022-04-06},
  eventtitle = {{{SOSP}} '13: {{ACM SIGOPS}} 24th {{Symposium}} on {{Operating Systems Principles}}},
  isbn = {978-1-4503-2388-8},
  langid = {english},
  keywords = {cse227,security},
  file = {/Users/yuan/Zotero/storage/WTQPWSU9/Wang et al. - 2013 - Towards optimization-safe systems analyzing the i.pdf}
}

@article{wulfHYDRAKernelMultiprocessor1974,
  title = {{{HYDRA}}: The Kernel of a Multiprocessor Operating System},
  shorttitle = {{{HYDRA}}},
  author = {Wulf, W. and Cohen, E. and Corwin, W. and Jones, A. and Levin, R. and Pierson, C. and Pollack, F.},
  date = {1974-06},
  journaltitle = {Communications of the ACM},
  shortjournal = {Commun. ACM},
  volume = {17},
  number = {6},
  pages = {337--345},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/355616.364017},
  url = {https://dl.acm.org/doi/10.1145/355616.364017},
  urldate = {2021-09-29},
  abstract = {This paper describes the design philosophy of HYDRA—the kernel of an operating system for C.mmp, the Carnegie-Mellon Multi-Mini-Processor. This philosophy is realized through the introduction of a generalized notion of “resource,” both physical and virtual, called an “object.” Mechanisms are presented for dealing with objects, including the creation of new types, specification of new operations applicable to a given type, sharing, and protection of any reference to a given object against improper application of any of the operations defined with respect to that type of object. The mechanisms provide a coherent basis for extension of the system in two directions: the introduction of new facilities, and the creation of highly secure systems.},
  langid = {english},
  keywords = {cse221,system},
  file = {/Users/yuan/Zotero/storage/PZP2QDK3/Wulf et al. - 1974 - HYDRA the kernel of a multiprocessor operating sy.pdf}
}

@inproceedings{zhangGeneralDiagnosisStatic2014,
  title = {Toward General Diagnosis of Static Errors},
  booktitle = {Proceedings of the 41st {{ACM SIGPLAN-SIGACT Symposium}} on {{Principles}} of {{Programming Languages}} - {{POPL}} '14},
  author = {Zhang, Danfeng and Myers, Andrew C.},
  date = {2014},
  pages = {569--581},
  publisher = {{ACM Press}},
  location = {{San Diego, California, USA}},
  doi = {10.1145/2535838.2535870},
  url = {http://dl.acm.org/citation.cfm?doid=2535838.2535870},
  urldate = {2020-04-07},
  eventtitle = {The 41st {{ACM SIGPLAN-SIGACT Symposium}}},
  isbn = {978-1-4503-2544-8},
  langid = {english},
  keywords = {pl},
  file = {/Users/yuan/Zotero/storage/APF6RBZT/Zhang and Myers - 2014 - Toward general diagnosis of static errors.pdf}
}


